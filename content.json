{"pages":[{"title":"","permalink":"/about/index-copyold-20200722.html","text":"基本信息姓名：张富强网站：http://gslnzfq.github.io邮箱：zhangfqmail@126.com微博：https://weibo.com/u/6286882668码云：https://gitee.com/fqzhangGithub：https://github.com/gslnzfq 简介前端经验5年，可独立负责项目基础框架搭建和开发。制定团队规范，前后端平滑沟通。快速适应环境，并可以和各部门同事梳理沟通，快速定位问题，团队协作力强。具有项目设计能力，有设计项目和管理项目的经验。 技术 JS基础扎实，对异步编程，Promise原理有较深的理解。了解Angular1,Vue,jQuery,React原理，能独立开发组件、独立搭建Angular1 和 Vue, React等前端开发框架。 熟悉HTML/CSS 知识，熟练使用 Bootstrap、Ant Design、less、媒体查询以及css3常见兼容方案。 有过前端性能优化的经验，曾使开发的一个项目运行速度提升至少2倍，熟悉常见的优化点以及原理。 熟悉前端模块化、编译打包等技术，熟练使用gulp, webpack等构建工具的配置和使用，熟悉并可以灵活的进行webpack配置。 了解NodeJS和Express框架，了解session、cookie、缓存等技术。开发过前端脚手架工具并适配团队基本所有的项目需求。 了解Java基础知识，能看懂简单的Java代码，熟悉常见数据库的安装和操作，有一年的Java项目经验。 熟悉Linux的常用命令，能熟练使用svn、git等工具进行团队协作开发，Mac/Linux爱好者。 熟悉nginx基本配置，熟练代理配置、rewrite方案进行前端多项目协同开发。 熟悉React组件化的开发，以及项目架构搭建和性能调优。 熟悉移动端H5开发，熟悉多种适配方案，并在项目实现。 作品 华三绿洲平台 GIFTO通用礼物 永恒玫瑰官方网站 GIFTO官方网站 CoinUp视频直播平台 GIFTO红包抽奖项目 webpack培训资料 工具 zenbone一个前端构建工具 protobuf文件批量转换js工具 谷歌和飞书API读取工具 其他我是一个爱好钻研技术的人，对编程有浓厚的兴趣。自学能力强，工作上用到的技术会很快的去研究学习，动手去做。工作过程中喜欢做挑战性的任务，喜欢对程序进行优化，对产品的要求很高，有代码洁癖。工作上喜欢分享自己的成果，注重团队合作，主动学习与自己工作内容相关的周边技术，提升在团队中的价值。管理方面，注重员工的培养和任务的合理化安排，让合适的人做合适的事情，也建议员工全面发展自己。我相信我自己的经验和知识可以为公司做出应有的贡献，也能让自己更快的成长，为公司发展带来更多的价值。"},{"title":"","permalink":"/jsfiles/callee.js","text":"function abc (aaa, bbb) { console.log(arguments.callee.caller === abc) } console.log(abc(1, 2, 3)) console.log(abc.length)"},{"title":"","permalink":"/about/index.html","text":"基本信息姓名：张富强学校：鞍山师范学院「计算机科学与技术」网站：http://gslnzfq.github.io邮箱：zhangfqmail@126.com码云：https://gitee.com/fqzhangGithub：https://github.com/gslnzfq 简介前端经验5年，可独立负责项目基础框架搭建和开发。制定团队规范，前后端平滑沟通。快速适应环境，并可以和各部门同事梳理沟通，快速定位问题，团队协作力强。具有项目设计能力，有设计项目和管理项目的经验。 技术 JS基础扎实，有三年的ES6/ES6+的使用经验，了解一些JS的设计模式。 熟悉HTML/CSS 知识，熟练使用 Bootstrap、Ant Design、less、媒体查询等。 熟悉React开发以及框架搭建和优化，对React-Router、Redux、Mobx能熟练使用。 熟悉Echarts，jQuery，ExtJS，jQuery UI等框架使用。 有Angular.js开发经验，有Vue的小项目经验，熟悉Vue语法。 有前端性能优化的经验，曾使一个项目运行速度提升至少2倍，熟悉常见的优化点以及原理。 熟悉前端模块化、编译打包等工具，熟练使用gulp, webpack等构建工具的配置和使用，熟悉并可以灵活的进行webpack配置。 熟悉移动端H5开发，熟悉适配方案，熟悉H5调试和错误定位。 了解NodeJS和Express框架，开发过基于Node前端脚手架并适用于团队开发需求。 了解Java基础知识，能看懂Java代码和常见的后端技术，有一年的开发经验。 熟悉Linux的常用命令，能熟练使用svn、git等工具进行团队协作开发，Mac/Linux爱好者。 作品 Uplive直播平台 CoinUp视频直播平台 GIFTO红包抽奖项目 GIFTO官方网站 GIFTO通用礼物 永恒玫瑰官方网站 webpack培训资料 华三绿洲平台 工具 zenbone一个前端构建工具 protobuf文件批量转换js工具 谷歌和飞书API读取工具 其他我是一个爱好钻研技术的人，对编程有浓厚的兴趣。自学能力强，工作上用到的技术会很快的去研究学习，动手去做。工作过程中喜欢做挑战性的任务，喜欢对程序进行优化，对产品的要求很高，有代码洁癖。工作上喜欢分享自己的成果，注重团队合作，主动学习与自己工作内容相关的周边技术，提升在团队中的价值。管理方面，注重员工的培养和任务的合理化安排，让合适的人做合适的事情，也建议员工全面发展自己。我相信我自己的经验和知识可以为公司做出应有的贡献，也能让自己更快的成长，为公司发展带来更多的价值。"},{"title":"","permalink":"/jsfiles/couqian.js","text":"// 1. 1元，2元，5元，10元，20元，50元，100元，凑钱, 手写。 /** * * @param list 可选钱的列表 * @param money 需要找的钱 */ function greedyMoney (list = [], money = 0) { let len = list.length, i = 0, result = []; list = list.sort((a, b) => b - a); for (; i < len; i++) { let n = list[i] while (money >= n && money > 0) { result.push(n); money = money - n; } } console.log(result); return result; } greedyMoney([11,5,1], 15);"},{"title":"","permalink":"/jsfiles/depend.js","text":"class Dep { // 初始化一个依赖的数据，为什么是一个数组，因为一个属性可能被多个computed所依赖 constructor () { this.deps = [] } depend () { // 此处由依赖的属性收集, 例如 obj.name被obj.info所引用，那个obj.info的监听函数就会自动注册到obj.name的依赖列表上 if (Dep.target && this.deps.indexOf(Dep.target) === -1) { this.deps.push(Dep.target) } } notify () { // 一旦被依赖的属性发生了变化就会通知依赖的computed属性进行更新 this.deps.forEach(dep => { dep() }) } } class Observable { constructor (obj) { return this.init(obj) } // 将obj上第一层所有的属性都定义为可观测的，目前只支持对象的递归观测 init (obj) { // 遍历所有的key Object.keys(obj).forEach(key => { this.defineReactive(obj, key, obj[key]) }) return obj } defineReactive (obj, key, val) { let dep = new Dep() // 如果值还是一个对象，就机柜观测 if (Object.prototype.toString.call(val) === '[object Object]') { this.init(val) } Object.defineProperty(obj, key, { set (value) { val = value // 值修改以后通知自己的依赖去更新 dep.notify() }, get () { dep.depend() return val } }) } } class Watcher { constructor (obj, key, cb, updateFn) { this.obj = obj this.key = key this.cb = cb this.updateFn = updateFn this.initComputed() } initComputed () { let me = this, // 每次更新需要调用的方法 onComputed = () => { let val = me.cb.call(me.obj) me.updateFn(val) } Object.defineProperty(me.obj, me.key, { set () { throw new Error('计算属性不能赋值') }, get () { // 添加依赖，如果存在就不重复添加 Dep.target = onComputed // 这里会调用依赖的字段的get方法，get方法又会去调用dep.depend()，所以就将这个依赖添加到了列表中 // 使用me.cb.call(me.obj) 这样就可以在cb中使用this获取obj的属性了 let val = me.cb.call(me.obj) // 添加完依赖需要情空 Dep.target = null return val } }) } } let aaa = new Observable({ name: 'zhangsan', age: 20 }) new Watcher(aaa, 'info', function () { return this.name + this.age; }, function (val) { console.log('new ', val) }) console.log(aaa.info) aaa.age = 900 console.log('outer new ', aaa.info)"},{"title":"","permalink":"/jsfiles/get-data-by-path.js","text":"let a = { name: 'zhangsan', info: { addr: { province: 'prov' }, age: 30 } } function getDataByPath (data, path) { let arr = path.split('.'), temp = data while (arr.length) { temp = temp[arr.shift()] if (temp === undefined) { break } } return temp } console.log(getDataByPath(a, 'info.addr.province'))"},{"title":"","permalink":"/jsfiles/huiwen.js","text":"let isHuiWen = function (str) { let newStr = str.toUpperCase().split('').reverse().join(''); return newStr === str.toUpperCase(); } console.log(isHuiWen('123210'))"},{"title":"","permalink":"/jsfiles/promise.js","text":"class Promise2 { constructor (factory) { let stack = [], // 存储了传进来的回调函数，为什么使用一个数组呢，是为了将所有的回调注册对应，否则会导致1resolve对应2回调 value = '', state = 'pending' this.then = (resolve, reject) => { stack.push({ resolved: resolve, rejected: reject }) return this } function resolve (data) { value = data state = 'resolved' // 执行所有收集的resolve回调 stack.forEach(obj => obj.resolve(data)) return this } function reject (msg) { state = 'rejected' // 执行所有收集的resolve回调 stack.forEach(obj => obj.reject(msg)) return this } if (typeof factory === 'function') { factory(resolve, reject) } } }"},{"title":"","permalink":"/jsfiles/quchong.js","text":"var b = [2, 2, 4, 1, 2, 1, 5, 8, 0]; var newb = []; for (var i = 0; i < b.length; i++) { // 看看是不是已经在新的数组里面了 var exist = false; for (var j = 0; j < newb.length; j++) { // 找到相同的就说明在数组了 if (newb[j] === b[i]){ exist = true; break; } } // 不存在再push if (!exist) { newb.push(b[i]); } } console.log(newb);"},{"title":"","permalink":"/jsfiles/resizeimage.js","text":"/** * 将dataURL转化成File对象 * @param dataurl * @returns {Blob} */ function dataURLtoBlob(dataurl) { let arr = dataurl.split(','); let mime = arr[0].match(/:(.*?);/)[1]; let bstr = atob(arr[1]); let n = bstr.length; let u8arr = new Uint8Array(n); while (n--) { u8arr[n] = bstr.charCodeAt(n); } return new Blob([u8arr], {type: mime}); } /** * 压缩图片 * @param file 文件对象，直接在input上可以获取 * @param maxSize 最大宽度或者高度, 如果 height > width => height = maxSize, width自适应；如果 width > height => width = maxSize, height自适应； * @param maxHeight 最大高度，只设置maxHeight，宽度自适应； * @param maxWidth 最大宽度，只设置maxWidth，高度自适应； * 三个尺寸参数值设置一个 优先级 maxWidth > maxHeight > maxSize * @returns {Promise} 返回Object */ export default function resizer({file, maxSize = 1800, maxHeight, maxWidth}) { if (file.type.indexOf('image') > -1 && /\\.(jpe?g|png|bmp)$/i.test(file.name)) { return new Promise((resolve, reject) => { const reader = new FileReader(); let imageResult = null; // 读取图片的数据 reader.readAsDataURL(file); reader.onload = (e) => { imageResult = e.target.result; let canvasImage = new Image(); canvasImage.src = imageResult; canvasImage.onload = function () { const {width, height} = canvasImage; let [newWidth, newHeight] = [0, 0]; // 如果图片本来就很小就不作处理了 if (maxWidth) { if (width"},{"title":"","permalink":"/jsfiles/sanjiaoxing.js","text":"function print (level) { for (let i = 1; i"},{"title":"","permalink":"/jsfiles/this.js","text":"setTimeout(function () { console.log(this) });"},{"title":"","permalink":"/jsfiles/two-way-binding.js","text":"let obj = { name: 'zhansgan', age: 90 } Object.keys(obj).forEach(key => { let val = obj[key] Object.defineProperty(obj, key, { set (value) { console.log(`set ${key} = ${val}`) val = value }, get () { console.log(`get ${key} = ${val}`) return val } }) }) console.log(obj.name) obj.name = 'lisi' console.log(obj.name)"},{"title":"","permalink":"/project/index.html","text":"我的作品PC网站 H5活动 工具"},{"title":"","permalink":"/jsfiles/scope.js","text":"// 作用域安全的构造函数 function Person (name, age, addr) { if (this instanceof Person) { this.name = name this.age = age this.addr = addr } else { return new Person(...arguments) } } let p1 = Person('zhangsan', 22, 'beijing') let p2 = new Person('zhangsan', 22, 'beijing') console.log(p1 instanceof Person) console.log(p2 instanceof Person)"}],"posts":[{"title":"Git中文文件名不能正常显示","permalink":"/ckilas0hi002a0xqidv9pw98o/","text":"表现在git中我们使用git status查询文件修改状态时，对于中文的文件名没有办法正常显示，效果如下图所示； 经过查询资料和git的设置有些关系； 开始修改目前我的电脑系统是macOS，Linux用户类似，windows用户由于文件的目录结构不同可能会有些不同，但是修改文件的内容是一样的； 我们可以修改Home目录中的.gitconfig文件，在文件的后面添加下面的配置： 12[core] quotepath = false 配置说明：https://git-scm.com/docs/git-config#Documentation/git-config.txt-corequotePath 修改完成后，重新打开shell，再执行git status发现，中文可以正常展示了。 这样看起来就很舒服了。 参考文章 https://git-scm.com/docs/git-config https://git-scm.com/docs/git-config#Documentation/git-config.txt-corequotePath"},{"title":"macOS设置nginx代理支持解析PHP","permalink":"/ckilas0i1003j0xqiy2ykuzgk/","text":"在开发时候，我们有时候需要给自己的机器配置一个域名，例如有三方认证的场景，回调地址不会是localhost。所以我们启动服务器的时候会从80端口上运行，然后我们使用webpack-dev-server的时候，只能启动一个项目到80端口上，所以我们可以使用nginx反向代理的方式对url进行处理。例如： 123www.webrepos.cn/blog http://localhost:8001www.webrepos.cn/bbs http://localhost:8002www.webrepos.cn/cms http://localhost:8003 然后开发时期，我们在本地配置host文件，写入下面的内容： 1127.0.0.1 www.webrepos.cn 然后我们启动本地的nginx服务器就会代理我们上面的地址，我们在nginx对location做一个代理就可以实现转发到不同的环境上了，并且登录的回调也是没有问题的。 使用nginx做反向代理，解析php文件，结合webpack-derv-server简直不要很爽啊。 安装首先安装nginx和php，此处使用brew来安装。 1brew install nginx php 1、配置php-fpm： 打开php-fpm的配置文件，如果没有就复制下默认的配置文件； 12# 的目录存在php-fpm.conf文件，直接跳过上面的步骤即可。下面的PHP版本和自己安装的一致sudo cp /usr/local/etc/php/7.2/php-fpm.conf.default /usr/local/etc/php/7.2/php-fpm.conf 修改配文件； 1234567; Error log file; If it's set to \"syslog\", log is sent to syslogd instead of being written; into a local file.; Note: the default prefix is /usr/local/var; Default Value: log/php-fpm.log; 下面的这一行默认是加上注释的，就是前面有个分号，直接删除，并修改城下面的值就可以了error_log = /usr/local/var/log/php-fpm.log 保存就好了。 2、配置下nginx，让其可以将php文件交由php-fpm来解析： 12# 如果没有的话就拷贝一份nginx.conf.default，命名为nginx.confvim /usr/local/etc/nginx/nginx.conf 在nginx对应的服务器部分加上下面的代码： 123456789location ~ \\.php$ &#123; # 这里的root需要按照你的要求进行配置，主要是描述的你的php存在的位置。 root /Users/admin/Source; # 注意这个名字一定要修改下，修改成$document_root才可以 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params;&#125; 3、我们启动下php-fpm，直接在命令行执行： 123sudo /usr/local/Cellar/php/7.2.5/sbin/php-fpm# 根据自己安装的来启动，注意版本重新加载下我们nginx服务器配置文件就可以了sudo nginx -s reload 大功告成；"},{"title":"QQ二次分享H5卡片内容","permalink":"/ckilas0gv000y0xqiq7yi00uf/","text":"我们H5页面在QQ里面打开后，点击QQ右上角分享到好友，会展示下面的样式 下面的链接以及右边的配图，给其他用户的感觉是不可信，类似垃圾链接等，用户点击的欲望不会很强烈。所以我们需要将分享的链接气泡正规化，下面是一个正常的案例 我们需要在html中加入下面的，让QQ内置浏览器在分享的时候读取 12345&lt;title&gt;好友默契大考验！&lt;/title&gt;&lt;meta name=\"title\" content=\"好友默契大考验！\"&gt;&lt;meta itemprop=\"name\" content=\"好友默契大考验！\"&gt;&lt;meta itemprop=\"description\" content=\"好友默契大考验，这段是描述\"&gt;&lt;meta itemprop=\"image\" content=\"缩略图\"&gt; 在QQ中，上述的meta标签甚至可以使用js在页面中生成，这对于多语言需求的页面比较实用； 如果发现问题，请在下方回复。 参考链接： https://blog.csdn.net/qq_41725450/article/details/100891853"},{"title":"页面中PNG图片优化","permalink":"/ckilas0jq00740xqio8pv3eyl/","text":"活动页面中例如页面背景等图片的尺寸都是很大的，png的尺寸一般是的100+kb，导致加载比较慢； 现在我们的方案就是在支持webp的浏览器中使用webp作为背景图减少体积，虽然webp是有损压缩，但是还可以接受； 实现方案：转换之前的png先使用tinypng (https://tinypng.com) 做一次压缩，再去转换；（为了减少转换次数，因为转换网站要排队比较慢，当然这里我们也可以在 https://tinypng.com/third-party 下载TinyPNG本地的客户端+Token，每月免费压缩500张图片） 1、将png转换成webp，可以使用转换网站：https://cloudconvert.com/png-to-webp 2、在项目中判断浏览器是否支持png，然后在全局添加class样式，再针对class样式我们替换对应的背景图片即可； 123456789101112131415// 这段代码放到html的最上面function check_support_webp() &#123; try&#123; return (document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0); &#125;catch(err) &#123; return false; &#125;&#125; // 参考：https://blog.csdn.net/jesslu/article/details/82495061 // 在html节点上添加class标识，这段代码必须在项目启动之前进行执行，保证不加载png图片if (check_support_webp()) &#123; $('html').addClass('sup-webp');&#125; 3、css使用示例； 1234567body &#123; background: #212643 url(\"../images/background.png\") no-repeat center top;&#125; .sup-webp body &#123; background-image: url(\"../images/background.webp\");&#125; Less使用示例，其他的类似使用&amp;嵌套就可以了（活动的同学需要看看和多语言的class是不是在同级）； 123456body &#123; background: #212643 url(\"../images/background.png\") no-repeat center top; .sup-webp &amp; &#123; background-image: url(\"../images/background.webp\"); &#125;&#125; webpack配置修改 scripts/webpack.common.js 中url-loader正则匹配修改成下面的内容，加上webp： 12345678module.exports = &#123; test: /\\.(png|jpe?g|gif|svg|ttf|woff2|eot|woff|mp3|mp4|swf|webp)(\\?.*)?$/i, loader: 'url-loader', // 小于3k, 转成base64 options: &#123; limit: 10000, name: 'assets/media/[name].[hash:5].[ext]', &#125;,&#125; 注意1、有些图片转换以后比png大，请不要替换；"},{"title":"将proto文件转化成js文件输出","permalink":"/ckilas0jb00620xqif9ircmqn/","text":"前言做这个的时候，是因为在做项目的时候，会有一些proto（Google Protobuf）文件，这些pb文件有时候会更新。如果每次我们人肉的去用pbjs（将proto文件转换成js文件的工具）转的话，比较麻烦。所以我干脆做个简单的工具直接调用下就可以了，一切按照配置走的。 注意：转pb的时候，对应的pb文件夹需要有google文件夹（谷歌内置的类型文件），否则可能会转换不成功或者报错。 google内置文件下载地址：https://gitee.com/fqzhang/google-pbs 安装已经发布到了npm上，可以直接安装使用了。 1sudo npm install pb2js protobufjs -g 配置在项目的文件夹创建一个对应的配置文件 pb2js.config.json ，写上pb文件对应的目录和文件名称，详细配置例如 123456789101112131415161718192021222324&#123; &quot;output&quot;: &quot;js/pb&quot;, &quot;files&quot;: [ &#123; &quot;basePath&quot;: &quot;/Users/app/Source/protobuf&quot;, &quot;protos&quot;: [ &quot;G.proto&quot;, &quot;H.proto&quot;, &quot;I.proto&quot; ] &#125;, &#123; &quot;basePath&quot;: &quot;/Users/app/Source/protobuf/tts&quot;, &quot;protos&quot;: [ &quot;A.proto&quot;, &quot;B.proto&quot;, &quot;C.proto&quot;, &quot;D.proto&quot;, &quot;E.proto&quot;, &quot;F.proto&quot; ] &#125; ]&#125; 配置文件分为两部分： output {String} 输出pb.js文件的路径，是相对于当前配置文件的路径。 files {Array{Object}} 配置的文件序列的块，主要是解决pb分布在好多目录的情况。 basePath {String} pb文件的目录 protos {Array} basePath下的pb文件名称 运行1234567891011pb2js 成功：/Users/app/Source/app/js/pb/a.pb.js成功：/Users/app/Source/app/js/pb/b.pb.js成功：/Users/app/Source/app/js/pb/c.pb.js成功：/Users/app/Source/app/js/pb/d.pb.js成功：/Users/app/Source/app/js/pb/e.pb.js成功：/Users/app/Source/app/js/pb/f.pb.js成功：/Users/app/Source/app/js/pb/g.pb.js成功：/Users/app/Source/app/js/pb/h.pb.js成功：/Users/app/Source/app/js/pb/i.pb.js 原理其实就是根据配置文件遍历执行了pbjs的命令，进行批量执行下面的命令实现的。 1pbjs -t js -p ../ xx.proto &gt; xx.js &amp;&amp; echo &quot;export default _root;&quot; &gt;&gt; xx.js"},{"title":"mixpanel打点不生效","permalink":"/ckilas0hz003f0xqic5zrybt4/","text":"使用了mixpanel打点，但是在后端没有查询到打点的数据，页面也没有发送打点的请求，通过查询相关资料发现，浏览器禁用了跟踪的设置； 在控制台执行mixpanel.track()也不会发送请求"},{"title":"webpack将css和js文件内容输出到html","permalink":"/ckilas0i900410xqim824a49q/","text":"对于小的项目，我们将css文件和js文件可以直接内联插入到html中，可以减少两次请求，达到优化的效果；当然比较大的项目我们可以注入一些公共的样式和js文件的到html中； 我们使用html-webpack-plugin的插件 https://github.com/DustinJackson/html-webpack-inline-source-plugin 使用方法首先安装内联文件的插件； 1npm install --save-dev html-webpack-inline-source-plugin 修改webpack配置； 123456789101112const HtmlWebpackInlineSourcePlugin = require('html-webpack-inline-source-plugin’);// 注意插件的参数是加在HtmlWebpackPlugin上的，不是插件上的module.export = &#123; plugins: [ new HtmlWebpackPlugin(&#123; // 这里我会注入所有的css和js到html中，也可以根据需求修改正则，只注入部分文件 inlineSource: '.(js|css)$' &#125;), new HtmlWebpackInlineSourcePlugin() ] &#125;; 注意 这里如果要注入css内容，还是需要使用插件（mini-css-extract-plugin）先将css文件抽离才可以注入到html文件中的； 因为这个插件是基于html-webpack-plugin，所以，html-webpack-plugin是必须要使用的，否则会报错。 参考链接 https://github.com/DustinJackson/html-webpack-inline-source-plugin https://github.com/jantimon/html-webpack-plugin"},{"title":"React长列表详情返回后保留位置","permalink":"/ckilas0h000170xqiwb57y2xi/","text":"在React项目中我们从列表点击到详情页面，再返回的时候，会回到列表的顶部，用户体验比较差； 适用环境： 列表页面使用的iscroll 列表使用的分页加载，及上划加载下一页 在列表页的任意位置点击到详情 返回到列表要定位到点击之前的滚动条位置 我们可以借助localStorage存储返回之前的位置，返回的时候重新数据并且滚动到对应的位置，详细实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React from 'react';// 处理兼容性，获取滚动的距离// 获取滚动条的位置function getScrollTop() &#123; let supportPageOffset = window.pageXOffset !== undefined; let isCSS1Compat = ((document.compatMode || \"\") === \"CSS1Compat\"); return supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;&#125;// 每页分页的大小const pageSize = 10;class List extends React.Component&#123; state = &#123; list: [], // 当前页面 currentPage: 1, // 是否首次加载 firstLoad: true, // 在点击到详情之前，列表的长度，方面下次取该长度的数据 lastLength: 0 &#125;; getListData()&#123; let that = this; let &#123;currentPage, list, firstLoad, lastLength&#125; = this.state; let size = pageSize; // 检查本地是否存储了，点击之前的位置信息 let pos = localStorage.getItem('list_pos'); if (pos) &#123; pos = JSON.parse(pos); // 当前页 currentPage = pos.currentPage; // 上次离开时候页面的长度 lastLength = pos.pageLength; // 上次来开时滚动条的位置 top = pos.top; // 清理缓存 localStorage.removeItem('list_pos'); &#125; // 表示在详情界面返回的，需要处理 let isDetailBack = top !== undefined &amp;&amp; firstLoad; if (isDetailBack) &#123; currentPage = 1; size = lastLength; &#125; fetchData(&#123;page: currentPage, pageSize: lastLength&#125;).then(data=&gt;&#123; // window.scrollTo(0, top); // 如果使用的iscroll，滚动到对应的位置上 scroll.scrollTo(0, Number(top)); &#125;) &#125; goDetail(id) &#123; // 存储当前页面scrollTop和页面的条数 const &#123;currentPage, list&#125; = this.state; const data = &#123; // 当前页，返回的使用 currentPage, // 当前的top top: this.scroll.y || getScrollTop(), // 当前拉取的数据长度 pageLength: list.length &#125;; localStorage.setItem('list_pos', JSON.stringify(data)); router.push('/detail/' + id ); &#125;&#125; 实际的实现步骤： 保存当前的页码，列表数据长度，滚动位置； 跳转到详情页面； 返回检查是否有第一步保存的数据； 有就获取列表数据长度和滚动位置； 请求列表长度数量的数据； 渲染列表，滚动位置，清理掉第一步保存的数据； 完成。"},{"title":"webpack4升级指南","permalink":"/ckilas0ib00450xqiugukmo75/","text":"因为webpack4有很多吸引人的特性，在开发的时候能能提高效率，所以将团队项目的webpack3升级到了webpack4； 新特性 对Node.js版本必须&gt;=8.9.4； 支持WebAssembly； 支持多种模块类型； 通过mode来处理开发环境和线上环境优化； 更简单配置的拆包功能； 更快的热加载功能； 零配置模块打包（output:./dist/main.js；entry:./src/index.js）； 更快的构建时间，大项目及其可观； 全新的插件系统，插件优化替换； 插件变化 nameModulesPlugin =&gt; optimization.nameModules； noEmitOnErrorsPlugin =&gt; optimization.noEmitOnErrors； CommonsChunkPlugin =&gt; optimization.splitChunks； UglifyJsPlugin =&gt;webpack-parallel-uglify-plugin； extract-text-webpack-plugin =&gt; mini-css-extract-plugin； 开始升级1、首先我们要将webpack相关的升级到最新的版本，此处是我本次升级的例子 123&quot;webpack&quot;: &quot;^4.30.0&quot;,&quot;webpack-cli&quot;: &quot;^3.3.1&quot;,&quot;webpack-dev-server&quot;: &quot;^3.3.1&quot; 2、相关的loader升级一下版本，以下面的Loader为例，其他的请查询文档 1234&quot;file-loader&quot;: &quot;^4.0.0&quot;,&quot;style-loader&quot;: &quot;0.23.0&quot;,&quot;url-loader&quot;: &quot;1.1.1&quot;,&quot;postcss-loader&quot;: &quot;3.0.0&quot;, 3、插件升级 12&quot;mini-css-extract-plugin&quot;: &quot;^0.6.0&quot;, // 替代一下抽取样式的 extract-text-webpack-plugin&quot;string-replace-webpack-plugin&quot;: &quot;^0.1.3&quot;, 4、升级webpack配置文件，下面是变更了的内容 css加载开发时期使用style-loader，发布事情使用mini-css-extract-plugin抽取到css文件； plugins删除ExtractTextWebpackPlugin，使用MiniCssExtractPlugin代替； 根节点添加mode属性，开发时期使用development，发布时期使用production（会有一些优化）； module节点中使用rules替换loaders，webpack4不支持使用loaders了； 1234567891011121314151617181920212223242526272829303132333435const MiniCssExtractPlugin = require('mini-css-extract-plugin');// 声明cssloaderconst cssLoader = &#123; test: /\\.(css|less)$/, use: [ 'css-loader', 'postcss-loader', 'less-loader' ]&#125;;// 开发模式使用style-loaderif (!env) &#123; cssLoader.use.unshift('style-loader');&#125; else &#123; cssLoader.use.unshift(&#123; loader: MiniCssExtractPlugin.loader, options: &#123;hmr: !env, reloadAll: true&#125; &#125;);&#125;module.exports = &#123; mode: env ? 'production' : 'development', module: &#123; rules: [ cssLoader ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: 'assets/[name].css', chunkFilename: 'assets/[name].[contenthash:8].chunk.css', &#125;) ]&#125;; 参考文档： https://webpack.js.org/configuration/#options https://webpack.js.org/guides/getting-started/#basic-setup https://segmentfault.com/a/1190000014685887 https://juejin.im/post/5bd03659e51d457aa63a66c8#heading-0 https://segmentfault.com/a/1190000013608316 https://www.cnblogs.com/cherryvenus/p/9808320.html https://www.jianshu.com/p/7a5f6cffdd87"},{"title":"滚动到底部加载下一页实现","permalink":"/ckilas0jg006g0xqizvmah1mg/","text":"随着网页风格的变化，许多分页方式使用了，上拉或者滚动加载下一页的方式，这样即减少了后端计算总数的过程，也为前端提供了新的交互方式。 下面是常见的滚动加载的实例； 12345678910111213141516171819202122232425262728let isLoading = false;/** * @param callback &#123;Function&#125; 混动以后的回调函数 */const scrollListener = (callback = e =&gt; e) =&gt; &#123; if (isLoading) &#123; return; // 防止多次触发事件 &#125; // 此处针对部分浏览器需要特殊处理一下 const docElement = document.documentElement; let scrollTop = docElement.scrollTop; // 700 在页面滑到底部前700px就可以加载,增加交互流畅性 // 刚刚滑到底部的情况： docElement.scrollTop + docElement.clientHeight = docElement.offsetHeight; if (typeof window.pageYOffset !== 'undefined') &#123; scrollTop = window.pageYOffset; &#125; if (scrollTop &gt; docElement.offsetHeight - docElement.clientHeight - 700) &#123; isLoading = true; callback(); &#125;&#125;;// window 注册滚动事件，可以后续使用节流减少事件的触发window.addEventListener('scroll', scrollListener);"},{"title":"使用Service Account读取谷歌表格","permalink":"/ckilas0hj002d0xqi993un5nf/","text":"前言随着谷歌表格API升级到第四个版本以后，虽然提供了更快的表格数据读取API，但是还有就是需要授权才能读取到数据，即使是发布到网络的表格。所以我们在做这一升级的时候，尝试了很多的方法，也走过了很多的坑，下面我就简单总结一下。 方案首先我找到了读取表格数据的API 接口： https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/get 该接口需要的参数如下（必传的参数）： 12345&#123; \"spreadsheetId\": \"\", \"range\": \"\", \"access_token\": \"\"&#125; 使用过的朋友都知道，spreadsheetId和range是表格的id和表格的tab范围。但是access_token并不是一个固定的东西，所以我研究了google获取access_token的两种方式（都是基于OAuth 2.0的）： 使用用户自己的账号，简单来讲就是通知用户授权，然后用户确认后可以拿到用户的access_token读取该用户拥有读取权限的表格数据。 使用服务账号，将表格共享给这个谷歌账号，然后使用服务器登录服务账号，获取服务账号的access_token读取表格数据。 刚开始的时候我使用了第一种方式，但是出现了下面的缺点： 需要写死一个账号，每次都是用这个账号进行授权。 access_token 的有效期很短（一般是两个小时），隔一段时间需要手动授权，需要人工的干预。 要是哪天我的账号被删除了就需要重新设置新的账号，并生成新的项目配置。 后来看到谷歌在服务器授权的时候，建议使用服务账号(虽然API KEY也可以)，就实现了服务端无用户参与的授权。 实现一、创建一个项目在开发者控制台创建一个项目link：https://console.developers.google.com/projectcreate 填写完必要的信息后，直接点击创建即可（注意项目的id不能修改）。 二、开通Google Sheet API服务在创建完账号以后就会跳转到该项目的dashboard，如下面的视图，直接在搜索框搜索Google Sheet API，如果不开启创建的服务账号是没有权限读取表格数据的。 在API页面直接点击启用即可开启该项目的Sheet API功能。 三、生成一个服务账号开启Sheet API以后会跳转到Sheet API的配置页面，我们现在为这个项目创建一个服务账号。 首先按照标记点击”凭据”，然后点击”API与服务中的凭据”来创建服务账号。 我们在这里选择创建”服务账号密钥”; 四、生成凭据点击上面的”服务账号密钥”跳转到了密钥创建页面，我们选择新的服务账号，根据自己的要求进行填写，如下所示。 这里我选择了JSON格式，方便Node.js（本次以Node.js作为实践）读取； 点击创建以后我们会得到一个json文件，注意改json文件一定要保存好了，后面的授权全靠它了。 接下来就开始编码实现读取的功能了; 五、开始编码下面是Node.js作为实现，首先需要安装googleapis。 1npm install googleapis --save 1234567891011121314151617181920212223242526272829303132333435363738const &#123;google&#125; = require('googleapis');// 后面的json文件就是我们在上面第四步下载的json文件。 const &#123;client_email: email, private_key: key&#125; = require('./service-account.json');// 指定权限，这里仅需要读取权限就可以了const scopes = ['https://www.googleapis.com/auth/spreadsheets.readonly'];// 全局存储授权后的token信息，后面也可以存储到redis等缓存中，现在为了测试，我就存储在本地的变量中let token = null;module.exports = &#123; authorize() &#123; return new Promise((resolve) =&gt; &#123; // 首先判断有没有token文件 if (token) &#123; const &#123;access_token, expiry_date&#125; = token; // 看看有没有过期 + 1分钟 if (expiry_date &gt; (new Date().getTime() + 60 * 1000)) &#123; return resolve(access_token); &#125; &#125; // 重新授权 let jwtClient = new google.auth.JWT(email, null, key, scopes); // 直接可以获取到access_token，很方便，不需要人工干预 jwtClient.authorize().then(data =&gt; &#123; // 保存token到全局变量 token = data; // 返回token resolve(data.access_token) &#125;).catch(() =&gt; &#123; resolve(''); &#125;); &#125;); &#125;&#125;; 然后我们通过上面的authorize可以取到token信息，最后使用ajax客户端来调用表格的接口，即可实现数据的读取。 为了保证隐私，我没有上传项目配置的json文件； 参考git实现：https://github.com/gslnzfq/develop-tools-server 六、测试如果读取数据的时候，google返回了403，那可能是因为你没有将表格共享给服务账号，查看服务账号： https://console.developers.google.com/iam-admin/serviceaccounts 在上面选择你的项目，就能看到右边的电子邮件，将谷歌表格共享给改邮箱就可以访问了。 参考文档 https://console.developers.google.com/projectcreate https://developers.google.com/identity/protocols/OAuth2?hl=zh_CN https://developers.google.com/sheets/api/guides/authorizing https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/get https://developers.google.com/apis-explorer/#p/sheets/v4/sheets.spreadsheets.values.get"},{"title":"在webpack4中module.exports导出的对象上属性丢失的问题","permalink":"/ckilas0i2003n0xqi2ywoi1vf/","text":"问题使用了webpack4，在复用以前的commonjs的模块时，发现对象上的属性丢失了，示例代码如下所示 1234567891011/** * @return string */function Test()&#123; return 'hello world';&#125;Test.name = 'test';Test.addr = 'Beijing';module.exports = Test; 然后在其他的文件中引入该模块 123import Test from './test';console.dir(Test); 在控制台查看，Test的name属性和addr属性不见了。 解决方案安装插件 1yarn add babel-plugin-add-module-exports -D 修改.babelrc，在插件中添加 12345678&#123; &quot;presets&quot;: [ &quot;react-app&quot; ], &quot;plugins&quot;: [ &quot;add-module-exports&quot; ]&#125; 该问题还在跟进，目前方案还在整理。"},{"title":"React中路由跳转到同一个组件数据不刷新","permalink":"/ckilas0k7007w0xqizeqfdiye/","text":"场景在使用React开发的时候，有时候我们可能会跳转路由了但是渲染的的是同一个组件，这样就导致路由跳转了，但是页面还是复用的之前的，没有刷新。 具体场景如下： 路由跳转使用的同一个组件，都使用的是Profile组件： 1// /profile/10 -&gt; /profile/11 相关代码 1&lt;Profile uid=&#123;uid&#125; onOpenProfile=&#123;this.goProfile.bind(this)&#125; /&gt; 原因主要是因为我们请求用户信息数据的方法写在了componentDidMount()生命周期（该生命周期只会在组件挂载的时候执行一次）中，导致了修改属性uid并不会重新拉取用户的数据，给用户一种没有刷新的感觉。 方案1、在跳转的时候给组件带上一个key，这样就每次都可以创建新的组件了（需要修改路由表）。 2、我们在Profile组件中监听一下uid的变化，重新加载用户数据，实现刷新（只需要修改组件本身，推荐）。 实现1、使用React-Router3，Router上的一个属性，可以手动渲染一个组件，具体实现如下（此处的userId是唯一的，所以能保证每次都是有的是最新的组件）。 1234567891011121314151617181920212223242526272829303132import React, &#123;Component&#125; from 'react';import &#123;hashHistory, Route, Router&#125; from 'react-router';import &#123;CreateGiftItem, Earnings, Land, Profile, Project, ProjectDetail&#125; from './host-views';class App extends Component &#123; static createElement = (Component, ownProps) =&gt; &#123; const &#123;userId&#125; = ownProps.routeParams; switch (Component) &#123; // Profile 不能是异步组件 case Profile: return &lt;Component key=&#123;userId&#125; &#123;...ownProps&#125; /&gt;; default: return &lt;Component &#123;...ownProps&#125;/&gt;; &#125; &#125;; render() &#123; return ( &lt;Router history=&#123;hashHistory&#125; createElement=&#123;App.createElement&#125;&gt; &lt;Route path=\"/\" getComponent=&#123;Land&#125;/&gt; &lt;Route path=\"/createitem/:step(/:id)\" component=&#123;CreateGiftItem&#125;/&gt; &lt;Route path=\"/project\" getComponent=&#123;Project&#125;/&gt; &lt;Route path=\"/project/detail/:id\" getComponent=&#123;ProjectDetail&#125;/&gt; &lt;Route path=\"/profile(/:userId)\" getComponent=&#123;Profile&#125;/&gt; &lt;Route path=\"/earnings(/:userId)\" getComponent=&#123;Earnings&#125;/&gt; &lt;Route path=\"*\" getComponent=&#123;Land&#125;/&gt; &lt;/Router&gt; ); &#125;&#125; 注意，看上面的代码实现，要手动渲染的组件不能是异步组件。 2、修改Profile组件，修改了uid我们重新刷新数据； 12345678910class Profile &#123; // ... componentWillReceiveProps(nextProps, nextContext)&#123; if (this.props.uid !== nextProps.uid) &#123; // uid变化以后重新加载用户信息 this.loadUserInfo(); &#125; &#125; // ...&#125;"},{"title":"Mac OS搭建支持https的nginx服务器","permalink":"/ckilas0hx003b0xqifu5a6sn2/","text":"作者原文: https://www.cnblogs.com/chenguoli/p/7845578.html 前言我们在本地进行项目使用nginx代理开发时，为了完全的模拟线上的环境，我们本地也需要使用https来运行，我们会在本地创建https的相关证书进行配置。 实现大家已经安装好了nginx吧，此处就不多说了，我用的是brew安装的nginx 首先我们找到我们安装nginx的配置文件的目录：/usr/local/etc/nginx 现在我们需要生成下面的四个文件： private.key server.crt server.csr server.key 1、生成私钥 1openssl genrsa -des3 -out private.key 2048 2、生成证书请求 1openssl req -new -key private.key -out server.csr 3、生成服务器的私钥，去除密钥口令 1openssl rsa -in private.key -out server.key 4、使用私钥为证书请求签名，生成给服务器签署的证书，格式是x509的PEM格式 1sudo openssl x509 -req -in server.csr -out server.crt -signkey server.key -days 3650 5、nginx配置 123456789101112131415161718192021222324server &#123; # 同时监听了80和443，网站可以使用http和https都可以访问了 listen 80; # http端口监听 listen 443 ssl; # https端口监听 server_name fqzhang.cn; index index.html; # ssl配置 ssl_certificate /data/crt/server.crt; ssl_certificate_key /data/crt/server.key; location / &#123; rewrite . /index.php last; &#125; # 下面是PHP的配置，需要安装和启动php-fpm才能使用 location = /index.php &#123; include fastcgi_params; fastcgi_pass 127.0.0.1:9000; fastcgi_param SCRIPT_FILENAME /data/www/blog/index.php; fastcgi_param SCRIPT_NAME /data/www/blog/index.php; &#125;&#125; 其他使用自定义证书支持的https服务器，在网站访问时，可能会出现不安全的提示，这个后面文章会继续研究，具体表现如下图所示："},{"title":"Swiper常见使用以及问题整理","permalink":"/ckilas0jw007s0xqihkpr96j9/","text":"swiper中文API：https://www.swiper.com.cn/api/index.html 1、实现下面的布局(主要看左右两边的) 上面的例子看出，中间部分居中在页面水平中央，两边显示一小部分,下面是关键代码： 1234567891011121314const newsSwiper = new Swiper('#newsSwiper', &#123; // 循环展示 loop: true, // 一秒钟换一次 number: 1000, // 自动播放 autoplay: true, // TODO 简直开心啊，这个设置小数太酷了，这个功能实现主要是因为这里设置了小数 slidesPerView: 1.4, // 两个图片之间的间距 spaceBetween: 10, // 激活的图片居中显示 centeredSlides: true&#125;); 2、手动滑动后自动轮播失效 参考：https://blog.csdn.net/MPQ1314/article/details/86702181 swiper轮播图设置自动轮播之后如果手动滑动之后，就不会再自动轮播了 解决方法： 12345678910var swiper = new Swiper('#swiper1', &#123; pagination: &#123; el: '.swiper-pagination', &#125;, loop:true, autoplay: &#123; // 加上这一行代码就可以了，具体原因请查看官方文档 disableOnInteraction: false &#125;&#125;);"},{"title":"使用nginx反向代理实现本地多项目运行","permalink":"/ckilas0it005a0xqia1g6l3qn/","text":"概述通过本文，你可以了解到nginx反向代理的相关知识，以及如何在Mac OS上进行实践。其实因为懒，这个文章好久就想写了。 一、起因在我开发GIFTO钱包和UG以及其他项目的时候，我们在启动项目的的时候默认会使用zenbone start来启动，因为我们配置的每个端口都是80，一个端口只能运行一个程序，就导致了多项目不能同时运行的问题。 二、方案现在我们有下面的几个方案： 修改多个项目的端口，每个项目会对应一个端口，然后使用webpack-dev-server进行启动，这样就可以同时启动多个项目了。 我们使用nginx做路径的反向代理，在 1 的基础上代理一些路径（一般是项目部署的路径）到本地测试服务器对应的端口上。 我们访问 /gwallet/ 会访问 http://localhost:3000 我们访问 /ugift2/ 会访问 http://localhost:3001 关于方案1： 如果我们的项目和域名没有关系，也和访问路径没有关系，那我们使用第一种方式那就足够了。 但是，我做的两个项目，都是需要配合域名来运行，原因有下面两个： 项目运行需要登录功能，登录的回调域名是固定的，配置在三方平台的后台系统。 在客户端里面配置的URL是固定的（UG或者是GIFTO钱包），在客户端调试的时候需要域名访问(当然也可以使用我们的协议的方式打开App的webview来调试)。 所以我最终选择了使用nginx做代理的方式实现。 三、实现该实现方式可能会涉及到nginx反向代理的相关知识，请看链接或者Google一下； 实现步骤分为下面的几部分（在Mac上实现，其他操作系统是类似的）： 使用homebrew安装nginx； 修改nginx配置文件； 启动nginx服务器； 启动本地项目的webpack-dev-server； 测试运行。 下面是详细的步骤： 1. 使用homebrew安装nginx我们这里介绍使用homebrew安装nginx，所以我们先要判断本机上是否安装了homebrew，执行下面的命令来检查安装。 看到上图的输出就说明已经安装了homebrew，不要误会，homebrew的执行命令就是brew。 如果提示command not found，我们就需要先安装homebrew。具体安装步骤请参考这里，当然安装的时候需要ruby环境，一般mac有会预置，没有也没有关系，可以自己安装一下，点击这里查看详细。 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 通过上面的操作我们已经安装好了homebrew，下面我们开始安装nginx。 稍等命令执行完成。 到这里我们的nginx就安装成功了。 2. 修改nginx配置文件安装以后我们可以在这个目录下找到nginx的配置文件： /usr/local/etc/nginx。 此处我们只修改简单的配置，就不创建server配置文件了，我们直接修改nginx.conf主配置文件即可，现在我们通过vim或者是sublime打开该配置文件，在没有修改之前(默认)是长这样子的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; # 是否打开发送文件 sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; # 该服务器监听端口是8080 listen 8080; # 使用localhost去访问 server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; include servers/*;&#125; 现在我们出去注释部分看一下server块，里面配置了启动的server的端口和域名。默认会有一个8080的服务器，其实对我们是没有用的，我们可以直接删除该server块，也可以不管，然后自己创建一个server块，其实也就是在server同级别添加一个server的配置，我的配置如下： 123456789101112131415161718192021222324252627282930313233343536373839# 钱包和UG的配置# up开头的是测试环境可能会用到的server &#123; listen 80; # server_name 是绑定的域名，就是说使用下面的域名访问的时候会使用该server块的配置，域名可以是多个，使用空格隔开即可。 server_name gifto.io m.upliveapps.com h5.upliveapp.com awsbj-game2u.xingyunzhi.cn localhost web.upliveapps.com m.giftomon.io up.live gifto.xingyunzhi.cn; # 域名是上面的任意一个 # 注意为了让nginx生效，要访问的域名必须要绑定host到127.0.0.1 # 当访问 http://m.upliveapps.com/uplive-login/ nginx就会直接代理到本地的8008端口 # 所以访问 http://m.upliveapps.com/uplive-login/index.html 的时候，其实访问的是http://127.0.0.1:8008/index.html ，下面的所有资源都会被代理 # http://m.upliveapps.com/uplive-login/index.html 这个地址其实也就是我们上线以后的地址，这样就保证了地址统一，包括登录等都完全可以模拟了 location /uplive-login/ &#123; proxy_pass http://127.0.0.1:8008/; &#125; location /iup-cash/ &#123; proxy_pass http://127.0.0.1:8010/; &#125; location /ugift2/ &#123; proxy_pass http://127.0.0.1:8001/; &#125; location /gwallet/ &#123; proxy_pass http://127.0.0.1:8002/; &#125; location /ugift/ &#123; proxy_pass http://127.0.0.1:8003/; &#125; location / &#123; index index.html; proxy_pass http://127.0.0.1:3000/; &#125;&#125; 修改完nginx的配置文件，我们还需要修改本地的hosts文件，加入你想使用m.upliveapps.com去访问nginx，就需要添加下面的行到 /etc/hosts。 1127.0.0.1 m.upliveapps.com 其他的是同理的。 3. 启动nginx服务器在mac下启动nginx服务器其实是很简单的，因为我们启动的服务器是在80端口上，所以我们使用sudo去启动，如下： 1sudo nginx 输入密码，回车就可以了 4. 启动本地项目的webpack-dev-server我们先找到一个项目，此处就以gwallet这个项目为例子，首先我们需要修改gwallet项目的启动端口，这个应该都是会的，就是修改webpack.config.js的devServer部分的port为8002，然后我们在控制台启动项目。 1webpack-dev-server 5. 测试运行我们看到项目启动成功以后，我们在浏览器访问 http://m.upliveapps.com/gwallet/index.html 如果没有看到你想看到的，请先看下下面的原因： hosts文件中 m.upliveapps.com 对应的ip是不是127.0.0.1 本地的webpack-dev-server是否已经启动了，可以使用http://127.0.0.1:8002/index.html 访问测试 看看nginx是否启动成功了，在浏览器中访问，出现502 Bad Gateway | nginx 的字样，就说明启动成功了，否则没有。 参考文章 反向代理 : https://juejin.im/entry/57fb07b0816dfa0056c0ada8 homebrew安装 : https://brew.sh/index_zh-cn Ruby安装 : https://www.ruby-lang.org/en/downloads/"},{"title":"使用html2canvas实现截图下载","permalink":"/ckilas0ik004q0xqiy9akocdg/","text":"场景有时候我们会将我们的网页保存为截图，供离线观看和传播。相对于直接保存一个网页，图片有着不易修改，单独文件的好处，所以实现网页的截图还是还有必要的。 方案经过在网上找一些插件，其中html2canvas插件用的人比较多，比较好的还有dom-to-image，这两个插件都可以实现网页的截图生成canvas功能。此处就以html2canvas为例记录一下笔记。 这两个插件都提供了npm包，所以可以直接使用npm下载。 1npm install html2canvas -S 主要的流程是： html2canvas实现dom转canvas =&gt; canvas转成base64 =&gt; 使用a标签的download属性实现下载功能。 实现先来一段html2canvas转canvas的代码（支持Promise），详细的文档可以看下：http://html2canvas.hertzen.com/ 123456789// http://html2canvas.hertzen.com/documentation 这个是详细的文档// 下面的this.content是一个dom节点html2canvas(this.content) .then(canvas =&gt; &#123; // 生成的canvas可以转成base64 &#125;) .catch(error =&gt; &#123; // 截图出错了我们要做的事情 &#125;) 然后我们使用生成的canvas来实现下载功能 1234567891011const url = canvas.toDataURL('image/png');// 先构建一个a标签const link = document.createElement('a');// 设置要下载的内容link.href = url;// 设置下载文件名称link.download = \"screenshot.png\";document.body.appendChild(a);// 模拟点击了a链接link.click();document.body.removeChild(a); 下面是完整的代码： 12345678910111213141516171819html2canvas(this.content) .then(canvas =&gt; &#123; // 生成的canvas可以转成base64 const url = canvas.toDataURL('image/png'); // 先构建一个a标签 const link = document.createElement('a'); // 设置要下载的内容 link.href = url; // 设置下载文件名称 link.download = \"screenshot.png\"; document.body.appendChild(a); // 模拟点击了a链接 link.click(); document.body.removeChild(a) &#125;) .catch(error =&gt; &#123; // 截图出错了我们要做的事情 alert('你的浏览器可能不支持canvas啊'); &#125;) 因为IOS上所有的浏览器都不支持a标签的download属性，所以没有办法下载。目前测试没有问题的浏览器： Mac系统： Firefox 60.0.1 Chrome 66.0 Safari 11.1 Android系统：写文章时最新版Chrome，Firefox Windows系统：写文章时最新版Chrome，Firefox 已知问题可是我使用不当吧，有解决方案的同学可以联系我： 就是发现截图的时候，如果有img或者是background有http://这种的就会导致图片丢失，我是直接把图片转成base64实现的，这样会导致文件有点大。（后面发现原因了，是因为图片的跨域的问题，需要设置CORS：https://www.cnblogs.com/padding1015/p/8947098.html） 还有一个就是a标签download属性会在有些浏览器上不支持修改文件名称，在国内的QQ浏览器上还会下载失败，暂时也没有找到解决方案。（不支持修改文件名称也是跨域的问题，如果是同一个域就可以修改文件名）"},{"title":"当窗口被浏览器拦截了怎么办？","permalink":"/ckilas0jc00660xqino9jecr5/","text":"前言有时候我们可能需要在一些场景来显示一些弹窗，但是程序弹出的窗口会被浏览器直接拦截掉，以为是恶意弹窗。所以我们针对这样的场景应该怎么解决了？下面的方案可能只是针对一部分场景。 方案经过查询资料和询问朋友同事，发现是用户主动通过事件的方式弹出的窗口，浏览器不会给拦截掉。所以我们可以先在用户点击的时候打开一个窗口，然后在我们需要异步打开窗口的时候直接设置location就可以了。但是这种方式使用第三方sdk异步打开窗口的时候不生效的。 实现12345678910111213141516// 首先我们定义一个事件，需要用户主动的触发function clickRedirect() &#123; // someAction是一个Promise对象，用来做异步处理的 let win = window.open(); someAction() .then(data=&gt;&#123; // 给打开的win设置url win.location.href = data.url; // 激活当前的win win.focus(); &#125;) .catch(err=&gt;&#123; // 直接关闭 win.close(); &#125;);&#125; 其实用户异步打开的功能上面就基本都实现了。 问题 在用户异步请求的这段时间，会显示一个空白的窗口，不知道怎么去解决？ 三方SDK打开的窗口没有办法去处理，需要开发者掌握对的时机，来触发打开？ 其他window.open() 会返回一个window对象，如果返回的是null时，我们也可以主动的提示用户屏蔽了弹窗，让用户允许该网站的弹窗。"},{"title":"使用DefinePlugin区分开发和线上打包优化","permalink":"/ckilas0ii004m0xqixg97lfwz/","text":"前言基于webpack开发的时候，我们有些代码只需要在开发时期来运行，例如打印详细的错误或警告信息。有些代码我们需要在线上运行的时候在执行，例如谷歌用户行为分析，如果在开发的时候就运行，会导致线上打点的结果不是很准确，失去了分析的意义。 实现今日我通过查看部分库的源代码，里面用到了webpack的DefinePlugin，这个插件可以定义一个webpack打包时的全局变量，在我们的代码中可以通过判断这个全局变量的值就来执行对应的代码(该插件在webpack3和webpack2中可以正常使用，在webpack4中没有深入研究）。 1、修改webpack配置由于DefinePlugin是webpack内置的，所以不需要单独的下载，具体修改的配置如下： 123456789module.exports = &#123; ... plugins:[ ..., new webpack.DefinePlugin(&#123; DEBUG: !/(product|stage)/.test(process.env.NODE_ENV) &#125;) ]&#125;; 这样我们就可以通过在编译的时候传入NODE_ENV参数来控制代码的执行了。如果我们传入的NODE_ENV包含stage或者是product就设置为false，否则就是true。 2、修改我们的业务代码我们在业务代码中加入判断就可以选择代码的执行了。 123456789if (DEBUG) &#123; // 这里是开发环境执行的代码 console.log('可查看详细的错误信息了');&#125; else &#123; // 不是开发环境了，就直接执行线上的代码，我们可以在这里做用户行为分析的功能或者其他 // 屏蔽console和alert const noop = () =&gt; &#123;&#125;; window.alert = () =&gt; &#123;&#125;;&#125; 还有一个好处就是线上打包的时候，uglifyjs通过代码分析，将 if (false) {} 这种的代码直接删除掉，根本就不会执行了。 3、运行测试怎么才能看出我们上面的插件有没有用呢，我们可以执行下面的代码，来看看控制台的打印就好了。 首先在我们的业务代码中使用 console.log() 来打印一下这个值（先不要屏蔽console测试）。 1console.log('是不否开发环境', DEBUG); 然后调用 webpack-dev-server 来查看。 1webpack-dev-server # 没有传递任何的环境变量，控制台会输出true 线上或者是测试环境运行。 12NODE_ENV=stage webpack-dev-server # 现在NODE_ENV是stage，控制台会输出falseNODE_ENV=product webpack-dev-server # 现在NODE_ENV是product，控制台也会输出false 既然输出都是正确的，那么我们通过判断的代码执行的逻辑也就是没有问题了 使用场景 我们在做谷歌分析或者TalkingData的时候，我们只有线上环境才会执行分析，开发环境不会调用对应的事件，我们就可以定义一个环境变量来判断当前的环境。 我们在线上需要屏蔽不必要的alert，我们也可以这样做。 其他开发时和运行时代码级别的差异化都可以使用这种方法去实现。 扩展阅读1、为什么我们要判断process.env.NODE_ENV呢？ 因为我们的webpack是运行的node环境中的，process对象是node内置的一个运行时线程对象，process.env存储的使我们所有的环境变量，可以在执行node程序之前临时加上一个环境变量，linux和mac下使用比较简单，只需要在要执行的程序之前添加 变量名=变量值 就可以使用process.env读取到，举个例子： 12NODE_ENV=stage webpack-dev-server # 执行webpack-dev-server的时候，取到的process.env.NODE_ENV就是stage， 其他的类似。 2、为什么windows，执行NODE_ENV=stage webpack-dev-server会出现错误。请查看：https://blog.csdn.net/shimazhuge/article/details/70172108"},{"title":"web使用facebook和line等分享","permalink":"/ckilas0if004f0xqiukqayp0t/","text":"前言​我们在做开发的时候，需要将自己开发的网页分享到facebook、telegram、line等页面。然后需要在分享到的社交软件或者是朋友圈的时候，展示一些和链接相关的文案和图片（也就是富媒体展示）。在国内的一些社交网站上可以调用SDK或者url使用传递参数的方式来展示分享的内容。 方案一、生成数据源​ 社交平台获取链接相关的信息时，一般都是通过抓取链接响应的meta标签来实现的（可以理解成我们使用ajax读取了我们传递的url的页面的信息，然后解析html结构读取meta标签上的配置信息）。因为不是在浏览器中运行，所以meta标签的数据在服务器端获取的时候就需要生成，不能抓取js来生成meta标签。meta标签分享的配置有一个协议（facebook制定的，很常用的三方社交网站支持这个协议），下面说一下这个协议。 OG协议首页：http://ogp.me/ 我们最常用的字段如下（此处不多做介绍，可以使用上面的链接自行查询API）： 1234567891011121314&lt;html prefix=\"og: http://ogp.me/ns#\"&gt;&lt;head&gt;&lt;title&gt;The Rock (1996)&lt;/title&gt;&lt;!-- 显示在分享上的title，一般是显示在第一行 --&gt;&lt;meta property=\"og:title\" content=\"The Rock\" /&gt;&lt;meta property=\"og:type\" content=\"article\" /&gt;&lt;!-- 显示在分享上的描述信息，一般是显示在第二行的小字 --&gt;&lt;meta property=\"og:description\" content=\"该网页的描述\" /&gt;&lt;meta property=\"og:url\" content=\"http://www.imdb.com/title/tt0117500/\" /&gt;&lt;meta property=\"og:image\" content=\"http://ia.media-imdb.com/images/rock.jpg\" /&gt;...&lt;/head&gt;...&lt;/html&gt; 下面有两种方式可以定制分享的内容： 1、使用静态的meta标签； ​ 简单来讲就是，将所有的数据写死在html文件head里面，这样的坏处就是不能根据内容来定制自己展示的样式，比较不常用，常见的方式是作为网站的宣传来分享使用，对于内容固定的场景。 2、使用后端语言生成meta标签； ​ 也算是服务端渲染的一个场景吧，就是根据我们传递的数据让后端动态生成图片文本等资源，这样做的好处就是显示的内容由用户定义，比较灵活；缺点是需要服务端的辅助，前端是实现不了的。还有部分三方应用并不支持动态的资源定义，就像telegram的分享，只能注册过的链接才会富媒体展示。 二、实现分享1、facebook分享方式facebook分享的时候需要在meta里面配置开发这id，详细： 使用SDK的方式（推荐） A、首先我们要加载facebook的sdk，加载方式：https://developers.facebook.com/docs/javascript/quickstart 1234567891011121314151617181920window.fbAsyncInit = function() &#123; // 到这里就说明FB加载成功了，这里我们一般会以事件的形式通知调用者来调用 FB.init(&#123; appId : 'your-app-id', autoLogAppEvents : true, xfbml : true, version : 'v3.0' &#125;); // 这里我做一个基于jq的事件通知 $('window').trigger('fbSdkLoaded'); window.fb = FB;&#125;; (function(d, s, id)&#123; var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) &#123;return;&#125; js = d.createElement(s); js.id = id; js.src = \"https://connect.facebook.net/en_US/sdk.js\"; fjs.parentNode.insertBefore(js, fjs);&#125;(document, 'script', 'facebook-jssdk')); B、我们配置一下我们要分享的页面的meta标签： 123456&lt;meta property=\"og:site_name\" content=\"这里是title\" /&gt;&lt;meta property=\"og:title\" content=\"这里也是title\" /&gt;&lt;meta property=\"og:url\" content=\"点击以后要跳转的地址\"/&gt;&lt;meta property=\"og:description\" content=\"这里是分享的描述文件\" /&gt;&lt;meta property=\"og:image\" content=\"这里是图片的地址\" /&gt;&lt;meta property=\"fb:app_id\" content=\"这里是fb的开发者id\"/&gt; C、开始分享我们的链接：https://developers.facebook.com/docs/sharing/reference/share-dialog，下面就封装一个分享的方法： 12345678910111213141516171819function share() &#123; function handle() &#123; // 这个方法的参数可以看上面的链接，不一定向下面的这样写。 FB.ui(&#123; method: 'share_open_graph', action_type: 'og.likes', action_properties: JSON.stringify(&#123; object:'https://developers.facebook.com/docs/', &#125;) &#125;, function(response)&#123;&#125;); &#125; if (window.fb) &#123; handle(); &#125; else &#123; // 如果没有加载成功，需要监听事件 $(window).on('fbSdkLoaded', handle); &#125; &#125; 使用链接的方式（也需要配置meta标签，同上） A、直接将location.href导向分享地址即可（注意里面的href需要使用encodeURIComponent方法转一下），在这里还是推荐使用SDK的方式分享。 12345https://www.facebook.com/dialog/share? app_id=145634995501895 &amp;display=popup &amp;href=你要分享给别人的地址 &amp;redirect_uri=分享成功后需要跳转的地址 2、line分享方式 使用链接的方式 A、我们先在要分享的页面加上meta的信息，这个不需要开发者id，例子： 12345&lt;meta property=\"og:title\" content=\"显示的title信息\"/&gt;&lt;meta property=\"og:description\" content=\"描述信息\"/&gt;&lt;meta property=\"og:image\" content=\"图片的地址\"/&gt;&lt;meta property=\"og:url\" content=\"点击以后要跳转的地址\"/&gt;&lt;meta property=\"og:type\" content=\"article\"&gt; B、这个比较简单，在分享的链接中配置好meta元数据后，直接使用链接就能实现分享到timeline或者好友群组等。下面是分享的链接： https://social-plugins.line.me/lineit/share?url=${encodeURIComponent(location.href)} 3、telegram分享方式 使用链接和机器人注册的方式 ​ 也是通过链接分享的，但是如果需要该链接富媒体展示，需要在机器人做注册（机器人注册时基于链接的，如果链接修改了，就不能显示富媒体了，即使参数和hash修改都会导致显示富媒体失败）。 A、去机器人注册一下你要分享的链接（机器人地址：https://t.me/webpagebot）; B、分享链接：https://t.me/share/url?url=你要分享的URL; C、你去调用一下分享，发现在聊天的是窗口已经可以展示图片和文本了。 参考 http://ogp.me/ https://telegram.wiki/general/website-sharing https://telegram.wiki/general/link-previews https://social-plugins.line.me/zh_TW/how_to_install https://developers.facebook.com/docs/sharing/reference/share-dialog https://developers.line.me/en/faq/ https://stackoverflow.com/questions/35268940/how-to-force-telegram-to-update-link-preview http://www.4u4v.net/meta-the-property-of-the-open-graph-protocol-open-content-protocol.html"},{"title":"H5适配iPhone X的底部圆角之flex布局改装","permalink":"/ckilas0gf000h0xqi0mjbjbct/","text":"现象在开发一款webapp的时候发现，fixed定位的顶部导航栏，当页面出现滚动条的时候就出现了iPhone X下面的黑线遮挡内容的情况，很影响操作。 方案既然知道是页面出现了滚动条出现导致的，所以就想办法干掉全局的滚动条，使用局部滚动，然而在div使用局部滚动条居然丑不堪言，后面又选择了better-scroll（选择的原因是其内置了上拉加载的特性、业务也需要该功能，之前用的是dropload）。 旧版实现看图说话 新版实现全部使用了flex布局，是典型的上中下结构，这样就让全局滚动条彻底不要了。 Better-Scroll使用遇到了困难此处需要重新写一篇文章说一下，简直不要太多了 使用上拉加载（显示正在加载和加载完成的文案）。 使用scrollTo滚动以后，手动滚动就出现了问题，卡了一下居然回到顶部了，据说scroll以后需要调用下refresh方法（https://github.com/ustbhuangyi/better-scroll/issues/419）。 scrollTo的y轴的位置不是window的scrollY（简直花了好长时间来调整的）。"},{"title":"Window下设置Git-Bash为Webstorm的默认Terminal","permalink":"/ckilas0hc001v0xqiumjbnxg0/","text":"原文：https://www.jianshu.com/p/6c29d366ca9c 当然我们使用wind10的朋友呢，可以直接使用wsl实现linux的操作，下面是针对不支持wsl的操作系统的修改。 Bash说明： 熟悉Linux的人，相对于cmd，可能更加喜欢bash。 Bash的命令都比较简单，并且功能强大。 git-bash支持了bash基础的一些命令。 Intellij IDEA 系列都支持该配置。 操作步骤： 打开 File -&gt; Setting -&gt; Plugins 搜索Terminal，勾选Terminal插件，点击确认。 会提示重启Webstorm，点击重启，重启后在状态栏上面就能可以看到Terminal标签了。 进入 File -&gt; Setting -&gt; Tools -&gt; Terminal，在 Shell path 那一栏中，输入你安装Git的位置，格式如下。 1&quot;C:\\Program Files\\Git\\bin\\sh.exe&quot; -login -i 点击保存设置，关闭Terminal重新打开就是git-bash了，第一次打开可能比较慢，耐心等候即可。"},{"title":"React-Router4升级之路","permalink":"/ckilas0gy00130xqi0up8nzkq/","text":"最近将React升级到了16.2，也将项目的React-Router升级了v4，我主要说一下我的升级之路。 参考： https://reacttraining.com/react-router/web/example/basic React 16 新特性1、render支持了多种的返回类型 2、更好的错误处理，新增componentDidCatch钩子 (http://blog.csdn.net/liwusen/article/details/78521006） 3、支持自定义DOM属性，属性会透传 4、体积更小（比15减少了32%），删除了内置的类型检查React.PropTypes 5、Portals（处理弹窗更加优化） 6、性能优化（https://www.itcodemonkey.com/article/1306.html） 参考：http://www.jb51.net/article/127955.htmhttp://blog.csdn.net/lx376693576/article/details/78192768 React Router v4 新特性1、全组件化 2、修复多次渲染问题 3、新的异步加载方式 安装下面就以React-Router和最新的React16为例子安装，由于React的API变化不是很大，此处就不多做介绍了。 先删除项目中依赖的旧版React和React-Router(如果不删除，升级需要指定版本号) 1npm uninstall react react-dom react-router --save 安装最新版本(此处的最新版本就是16和4，注意router的包名称是react-router-dom, history是用来访问历史的) 1npm install react react-dom react-router-dom history --save 查看项目目录下面的package.json 123456\"dependencies\": &#123; \"history\": \"^4.7.2\", \"react\": \"^16.2.0\", \"react-dom\": \"^16.2.0\", \"react-router-dom\": \"^4.2.2\" &#125; 使用一、路由的配置方式先上代码了 123456789101112131415161718import React from 'react';import &#123;HashRouter, Route, Switch&#125; from 'react-router-dom';class App extends Component &#123; render() &#123; return ( &lt;HashRouter&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;BindEmail&#125;/&gt; &lt;Route path=\"/bindemail\" component=&#123;BindEmail&#125;/&gt; &lt;Route path=\"/bindemailresult/:type\" component=&#123;BindEmailResult&#125;/&gt; &lt;Route path=\"/updatepassword\" component=&#123;UpdatePassword&#125;/&gt; &lt;Route path=\"/updatemail\" component=&#123;UpdateMail&#125;/&gt; &lt;Route component=&#123;BindEmail&#125;/&gt; &lt;/Switch&gt; &lt;/HashRouter&gt; ); &#125;&#125; 看上面的代码首先要注意几点 Router替换成了HashRouter，并且少了一个history的属性，当然你也可以使用BrowserRouter不过需要后台支持。 Route中删除了getComponent属性，那我们异步加载怎么办呢，下面会说一下。 多了一个Switch组件，以前设置404路由的时候只要在最后加上path=”*”就好了，但是现在只需要在最后加一个路由并且由Switch组件包裹即可。 第一行的Route上有一个exact属性，这个属性说明精确匹配，否则所有/开头的组件都会展示/配置的组件(比较绕，可以到时候讲一下)。 HashRouter组件内部只能包含一个组件，如果有多个会直接报错。 当然了，我们导入的时候只需要导入react-router-dom。 4很重要，不要忽略 二、异步加载的方式我们可以使用高阶组件和webpack的import方法进行异步加载js。 首先我们得有一个用来加载异步组件的高阶组件，我们暂且称之为”asyncComponent”，实现如下： harmony123456789101112131415161718192021222324252627282930313233import React from 'react'export const asyncComponent = loadComponent =&gt; ( class AsyncComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; Component: null &#125; &#125; componentWillMount() &#123; if (this.hasLoadedComponent()) &#123; return &#125; loadComponent() // 取到module的default作为组件，因为我们导出组件的时候使用的是 export default .then(module =&gt; module.default) .then((Component) =&gt; &#123; this.setState(&#123;Component&#125;) &#125;) .catch((err) =&gt; &#123; console.error(`Cannot load component in &lt;AsyncComponent /&gt;`); throw err &#125;) &#125; hasLoadedComponent() &#123; return this.state.Component !== null &#125; render() &#123; const &#123;Component&#125; = this.state; return (Component) ? &lt;Component &#123;...this.props&#125; /&gt; : null &#125; &#125;); 我们将需要拆分的js文件，进行下面的处理，import方法会返回一个promise，注意/ webpackChunkName: “test” / 这种注释不能删除，它描述了拆分后的文件名称。 1234567891011import &#123;asyncComponent as async&#125; from './views/async'// 测试export const Test = async(() =&gt; import(/* webpackChunkName: \"test\" */ './test'));// 绑定邮箱export const BindEmail = async(() =&gt; import(/* webpackChunkName: \"bindemail\" */ './views/bindemail'));// 修改密码export const UpdatePassword = async(() =&gt; import(/* webpackChunkName: \"updatepassword\" */ './views/bindemail/updatepassword'));// 修改邮箱export const UpdateMail = async(() =&gt; import(/* webpackChunkName: \"updatemail\" */ './views/bindemail/updatemail'));// 邮箱绑定结果export const BindEmailResult = async(() =&gt; import(/* webpackChunkName: \"bindemailresult\" */ './views/bindemail/result')); 然后我们在路由中直接配置component属性就好了，相比之前会简单一点 1&lt;Route path=\"/bindemail\" component=&#123;BindEmail&#125;/&gt; 三、可编程路由(路由切换) 我们一般会在js中获取路由的参数，我们以前的方式是这样的 1this.props.route.params.xxx; 在v4中，会在props上挂载一个match对象，所以获取参数，使用下面的方式 1this.props.match.params.xxx 参考：https://reacttraining.com/react-router/web/api/match 在代码中切换路由，以前是直接调用hashHistory的方法切换，如 12import &#123; hashHistory &#125; from &apos;react-router&apos;;hashHistory.push(&apos;/home&apos;); 在v4中将操作历史的工具单独抽离了，也就是history包，API和hashHistory基本一致 123import &#123; createHashHistory &#125; from &apos;history&apos;;const history = createHashHistory();history.push(&apos;/home&apos;); 问题 低端的浏览器上面可能不支持Map和Set类，会报错： 1Map is not undefined 解决方案：安装core-js，在引入Set，Map相关的语法糖（或许你也可以babel-polyfill，React官方使用的是core-js），如下就可以了 123456import Map from 'core-js/es6/map';import Set from 'core-js/es6/set';// 绑定在window上，就可以全局访问了window.Map = Map;window.Set = Set; 参考：https://reactjs.org/docs/javascript-environment-requirements.html"},{"title":"使用webpack插件抽取项目中的less文件","permalink":"/ckilas0ix005h0xqiu9fxt851/","text":"前言在项目中我一般喜欢一些预处理css处理器来开发代码，首先是因为灵活，其次就是能很好的处理样式的命名空间，防止样式冲突。 场景在React相关的项目开发中，我们的开发方式是每一个组件中会有一个单独的less文件，如果需要让分散在项目中的less文件全部抽取到一个统一的css文件中，就需要用到extract-text-webpack-plugin插件实现样式的抽取。 该插件是webpack 4.0.0版本之前使用的，4.0.0的后续版本会有新的工具使用； 原因之前会抽取到两个css文件，由于历史原因，只能加载一个css文件，这就导致了有一部分的样式缺失，没有办法加载。 解决方案将css和less文件使用同一组loader去加载，这样就能输出到同一个css文件了，详细实现的代码如下； 12345678910111213141516171819202122const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.(less|css)$/, use: ExtractTextPlugin.extract(&#123; use:[ 'css-loader','less-loader'], fallback: 'style-loader', &#125;), &#125;, ], &#125;, plugins: [ new ExtractTextPlugin(&#123; filename: 'index.css', disable: false, // 这个参数是必须的，否则只能抽取到入口文件中的css文件 allChunks: true, &#125;), ],&#125;; 需要注意的是，没个组件或者模块需要用自己独立的命名空间，否则合并成一个css后会导致样式覆盖的问题；"},{"title":"Docker给运行中的容器添加映射端口","permalink":"/ckilas0gd000f0xqip8zlwd9p/","text":"方法11、获得容器IP将container_name 换成实际环境中的容器名1docker inspect `container_name` | grep IPAddress 2、 iptable转发端口将容器的8000端口映射到docker主机的8001端口1iptables -t nat -A DOCKER -p tcp --dport 8001 -j DNAT --to-destination 172.17.0.19:8000 方法21.提交一个运行中的容器为镜像1docker commit containerid foo/live 2.运行镜像并添加端口1docker run -d -p 8000:80 foo/live /bin/bash 转载: http://blog.csdn.net/github_29237033/article/details/46632647"},{"title":"iScroll在安卓和IOS点击失效和点击两次解决方案","permalink":"/ckilas0hn002l0xqix2red29z/","text":"转载： https://www.cnblogs.com/chaser-li/p/7418678.html 12345 myScroll = new IScroll(\"#ID\", &#123; scrollbars: true,//有滚动条 mouseWheel: true,//允许滑轮滚动 fadeScrollbars: true//滚动时显示滚动条，默认影藏，并且是淡出淡入效果&#125;); 在 iOS上点击有效，在Android上点击无效。123456myScroll = new IScroll(\"#ID\", &#123; click:true, //调用判断函数 scrollbars: true,//有滚动条 mouseWheel: true,//允许滑轮滚动 fadeScrollbars: true//滚动时显示滚动条，默认影藏，并且是淡出淡入效果&#125;); 此时在android上点击有效，不过在IOS上就要点击两次才有效！ 解决办法：123456789101112131415myScroll = new IScroll(\"#ID\", &#123; click:iScrollClick(), //调用判断函数 scrollbars: true,//有滚动条 mouseWheel: true,//允许滑轮滚动 fadeScrollbars: true//滚动时显示滚动条，默认影藏，并且是淡出淡入效果&#125;);function iScrollClick()&#123; if (/iPhone|iPad|iPod|Macintosh/i.test(navigator.userAgent)) return false; if (/Chrome/i.test(navigator.userAgent)) return (/Android/i.test(navigator.userAgent)); if (/Silk/i.test(navigator.userAgent)) return false; if (/Android/i.test(navigator.userAgent)) &#123; var s=navigator.userAgent.substr(navigator.userAgent.indexOf('Android')+8,3); return parseFloat(s[0]+s[3]) &lt; 44 ? false : true &#125;&#125;"},{"title":"eslint报错\"unexpected token = \"","permalink":"/ckilas0hg00230xqidga0teea/","text":"配置eslint的时候，出现了下面的错误1unexpected token = 源码：123456789101112131415import React from 'react'; export default class Asset extends React.Component &#123; static propTypes = &#123; articleImageUrl: React.PropTypes.string.isRequired, &#125;; render() &#123; return ( &lt;div className=\"article__asset\"&gt; &lt;/div&gt; ); &#125;&#125; 解决方案 因为默认的解析器不支持es6的语法，所以会报错，我们在这里安装上babel的解析器就可以了； Use the babel-eslint parser in your ESLint configuration.npm install babel-eslint –save 1234&#123; \"parser\": \"babel-eslint\", \"plugins\": [\"react\"]&#125; 参考：https://stackoverflow.com/questions/37361104/eslinterror-in-plugin-gulp-eslint-parsing-error-unexpected-token"},{"title":"js检测手机浏览器切换到后台的方案","permalink":"/ckilas0ht00300xqiuki37tb8/","text":"需求：使用H5打开一个本地的app（本地app有相关协议可以被H5拉起），如果本地没有安装这个app，就跳转到该app的下载页面。 实现思路H5打开app时，会将浏览器切换到后台，所有我们可以延迟检测浏览器的是否隐藏就可以来决定是跳转下载页面（没有安装app），还是已经打开app了。 注意安卓上H5在非浏览器环境（webview）中直接打开app（使用自定义的protocol，例如myapp://）会被所寄生的app拦截，所以判断UA，如果不是浏览器，先提示在浏览器中打开。 js实现方法123456789101112131415161718192021222324252627282930const isAndroid = /[aA]ndroid/i.test(navigator.userAgent);const isIOS = /(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent);const NativeObj = &#123; openUrlCallApp()&#123;&#125;&#125;;const appDownloadPage = 'https://apk.google.com/xxx';// 获取页面的可见性const getDocVisible = () =&gt; &#123; if (document.hidden !== undefined) &#123; return !document.hidden; &#125; if (document.webkitHidden !== undefined) &#123; return !document.webkitHidden; &#125; return document.visibilityState === 'visible';&#125;;function openApp()&#123; // 尝试启动app,NativeObj是底层对跳转的封装 NativeObj.openUrlCallApp(); // 如果是安卓，同时启用一个延时，判断页面是否切换走了 if (isAndroid) &#123; // 在安卓手机中打开，页面转向下载页面 // 延迟1s判断页面的状态，如果没有被别的页面遮盖就说明没有跳转，就跳转到下载页面 setTimeout(() =&gt; &#123; if (getDocVisible()) &#123; location.href = appDownloadPage; &#125; &#125;, 1000); &#125;&#125; 已知问题如果在手机上安装了两个注册相同protocol的app，会出现打开方式，也会导致跳转到下载页面，这种情况暂时没有解决。 参考https://developer.mozilla.org/zh-CN/docs/Web/API/Document/visibilityState"},{"title":"安卓chrome上iscroll不能滚动的问题","permalink":"/ckilas0j7005v0xqiyxnzldbt/","text":"安卓上chrome浏览器iscroll滚动有问题，电脑端没有问题，经过查资料，有了下面的解决办法： 在html文件的head的最上端加上一段脚本即可。1&lt;script&gt;window.PointerEvent = void 0&lt;/script&gt; 参考：https://segmentfault.com/q/1010000008489619完整html文件如下：123456789101112131415&lt;!doctype html&gt;&lt;html lang=\"zh-CN\" xml:lang=\"zh-CN\"&gt;&lt;head&gt; &lt;title&gt;UpLive&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"/&gt; &lt;meta name=\"format-detection\" content=\"telephone=no\"/&gt; &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/&gt; &lt;script&gt;window.PointerEvent = void 0&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"wrap\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"图片预加载方案","permalink":"/ckilas0j4005o0xqid2civ3so/","text":"一个关于图片预加载的项目，始终还是遇到了图片预加载（废话）。 现象在开发活动项目的时候，有一个转盘抽奖的功能，要求抽到每个奖项的时候显示不同的图片，我们内心是这样想的； 然而现实却是这样，图片去哪里了啊，原来是图片比较大（之前没有做优化）加载比较慢，所以我们看到了文本，但是没有看到背景 因为红包组件是动态替换背景图片的，所以图片没有缓存的时候，都需要立即发请求，所以就导致了加载慢的问题；示例代码：123456789&lt;div className=&#123;'redpack-content ' + (show ? 'animated bounceIn' : 'redpack-hidden')&#125; style=&#123;&#123;backgroundImage: 'url(\"' + imgArr[level] + '\")'&#125;&#125;&gt; &lt;div className=\"redpack-text center\"&gt; &#123;textArr[level]&#125; &lt;/div&gt; &lt;div className=\"redpack-x\"&gt; &lt;img onClick=&#123;this.closeClick&#125; src=&#123;require('../../../images/homev2/redpackage/x.png')&#125;/&gt; &lt;/div&gt;&lt;/div&gt; 每次按照奖项的index来获取数组中存储的图片 原理图片资源下载一次后，第二次就会从缓存取。下载图片和网络有很大的关系，尤其是国外的服务器，在缓存取的时候和网络没有关系，是很快的。但是有一个条件：服务器必须设置浏览器可缓存，否则预加载没有任何意义，因为每次都会去服务器拉取最新的资源。 实现在页面加载完成时，或者setTimeout加载所需的图片，示例代码12345678910111213141516171819202122232425262728// 预加载图片// 这里每次加载5个图片，每一批间隔是1sconst preLoadConfig = &#123;size: 5, interval: 1000&#125;;const preLoadImage = (imageArr = []) =&gt; &#123; // 如果没有图片直接返回 if (!imageArr.length) &#123; return &#125; setTimeout(function () &#123; imageArr.splice(0, preLoadConfig.size).forEach(item =&gt; &#123; let img = new Image(); img.src = item &#125;); preLoadImage(imageArr) &#125;, preLoadConfig.interval)&#125;; // 开始加载图片，这个应该放在页面的入口处preLoadImage([ require('../../../images/homev2/redpackage/thank.png'), require('../../../images/homev2/redpackage/2p.png'), require('../../../images/homev2/redpackage/1p.png'), require('../../../images/homev2/redpackage/10g.png'), require('../../../images/homev2/redpackage/15g.png'), require('../../../images/homev2/redpackage/3g.png'), require('../../../images/homev2/redpackage/80g.png'), require('../../../images/homev2/redpackage/5g.png')]) 延迟一秒获取剩余的图片，防止和其他的请求一起，导致请求阻塞（浏览器有同源请求上限）。new Image()创建对象，指定src的时候会下载指定的图片，等下次请求的时候就是 from disk 或者 from memory 了，速度显然快了很多 优化结果不废话，看效果（页面首次加载时）抽中红包后一看，这货花了6ms，简直无法感知。 到这里，你也许看完了，文中有问题的请帮我指正，谢谢阅读。"},{"title":"docker基础使用入门","permalink":"/ckilas0he00210xqifrz9eunv/","text":"随着微服务化，docker的使用也越来越常见了，我下面总结了一下docker常见的命令使用； 一、镜像相关 docker images，显示下载的所有镜像； 12REPOSITORY TAG IMAGE ID CREATED SIZEjenkinsci/blueocean latest 810b3bb0601c 8 days ago 563MB docker pull imageName，在服务器上下载镜像； docker rmi imageName，删除本地的镜像，例如：docker rmi jenkinsci/blueocean； 二、容器相关 注意：下面的Container Name也可以使用Container ID代替 docker create [options] imageName [COMMAND]，创建一个容器，下面是常见的配置； 123456789101112131415161718192021222324~ ➤ docker create --helpUsage: docker create [OPTIONS] IMAGE [COMMAND] [ARG...]Create a new containerOptions: --add-host list 添加hosts对应关系，格式就像系统的host配置文件 (host:ip) --dns list 设置dns服务器，可以是多个值 -e, --env list 设置环境变量，可以是多个值 --env-file list 环境变量的env文件 --expose list 对外暴露的端口，可以是多个 -h, --hostname string Container host name --ip string IPv4 address (e.g., 172.30.100.104) --link list 关联到其他的容器，互通访问 --link-local-ip list Container IPv4/IPv6 link-local addresses --mount mount Attach a filesystem mount to the container --name string Assign a name to the container -p, --publish list 端口映射，格式=&gt; hostPort:containerPort -P, --publish-all 将容器expose的端口随机的映射到主机上 -t, --tty Allocate a pseudo-TTY -u, --user string Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;]) -v, --volume list 将容器的地址映射到本地的地址上，为了资源共享 -w, --workdir string Working directory inside the container docker start containerName， 启动已经创建好的容器；docker stop containerName，停止运行中的容器；docker restart containerName，重新启动运行中的容器；docker run [OPTIONS] IMAGE [COMMAND]，是docker create和docker start的合并，创建并启动容器； docker exec -it containerName COMMAND，进入容器并执行COMMAND命令；docker logs -f containerName，递增式打印日志； docker ps -a，显示所有的容器123~ ➤ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9566755c6d8e jenkinsci/blueocean &quot;/sbin/tini -- /usr/…&quot; 8 days ago Exited (143) 3 days ago jenkins 临时启动一个docker，停止后删除容器 1~ ➤ docker run -d xxx 更新待续；"},{"title":"使用HTML5的FileReader对象进行图片的读取和展示","permalink":"/ckilas0jo006y0xqi2ixwdb10/","text":"场景使用file选择一个图片，上传到服务器，如果成功了。就替换图片。 实现1、首先由一个html片段，包括一个预览图片的容器和一个选择图片的文件选择器。123456&lt;div&gt;&lt;!-- 显示选中的图片 --&gt;&lt;div id=\"imageBox\"&gt;&lt;/div&gt;--&gt;&lt;!-- 选取文件框 --&gt;&lt;input id=\"file\" type=\"file\" accept=\".png\"&gt;&lt;/div&gt; 2、在js中监听change事件，进行处理（js要放在body后面，否则取不到节点），如果是React需要放在componentDidMount生命周期中执行，也可以直接绑定事件。1234567891011121314151617181920// 监控上传文件的修改事件document.getElementById('file').onchange = (e) =&gt; &#123; const img = e.target.files[0]; const reader = new FileReader(); // 判断是不是一张图片 if (img.type.indexOf('image') &gt; -1 &amp;&amp; /\\.(jpe?g|png|bmp)$/.test(img.name)) &#123; reader.readAsDataURL(img); reader.onload = (e) =&gt; &#123; http.request() .success(data=&gt;&#123; // 这里替换的是背景，如果是img，直接重写src就可以了 document.getElementById('imageBox').style.backgroundImage = `url(\"$&#123;e.target.result&#125;\")`; &#125;) &#125;; return; &#125; // 上传以后置空，防止下次选择同一个文件不会触发onchange事件 e.target.value = null; alert('请选择一个图片文件');&#125;; 参考了MDN的FileReader API：https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader 还有一些高级的用法，请查看MDN。"},{"title":"Vue依赖收集的相关知识","permalink":"/ckilas0k6007v0xqi9qkxuoth/","text":"最近在学习Vue，觉的双向绑定和计算属性很神秘，所以看了下源码 Vue使用基于ES5新增特性Object.defineProperty()的set,get方法进行数据拦截做双向绑定； 非响应式对象下面的代码虽然修改了a.name,但是不能感知，我们需要做的怎么部署一个响应的属性，它的变动我们可以做一些事情； 1234let a = &#123; name:'zhangsan'&#125;;a.name = 'lisi' 响应式对象下面我们用Object.defineProperty()修改一下上面的对象 12345678910111213141516171819202122232425let obj = &#123; name: &apos;zhansgan&apos;, age: 90&#125;Object.keys(obj).forEach(key =&gt; &#123; let val = obj[key] Object.defineProperty(obj, key, &#123; set (value) &#123; console.log(`set $&#123;key&#125; = $&#123;val&#125;`) val = value &#125;, get () &#123; console.log(`get $&#123;key&#125; = $&#123;val&#125;`) return val &#125; &#125;)&#125;)console.log(obj.name)obj.name = &apos;lisi&apos;console.log(obj.name)// get name = zhansgan// zhansgan// set name = zhansgan// get name = lisi// lisi 通过上面的处理，我们读取或者是设置name的时候就会打印消息，所以obj这个对象就变得可观测了，如果修改了，我们也可以做一些事情；还有一个很重要的就是vue的computed特性，我们主要看看是怎么收集依赖的； 在上面的基础上，我们希望在obj上添加一个属性info，这个属性的值决定于obj.name和obj.age，一旦一个发生变化我们修改下info的值，并且info只读假如现在的规则是： obj.info = obj.name + obj.age我们实现可以使用监听name和age的变化，开重新计算info，但是现在只有两个属性还好，要是有多个，我们的程序就难以阅读和控制，例如：obj.info = obj.a + obj.b + obj.c + obj.d 依赖收集原理收集依赖主要由三部分构成:Observable（设置对象可观测）,Dep（依赖收集）,Watcher（定义计算属性），主要代码实现如下所示: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091class Dep &#123; // 初始化一个依赖的数据，为什么是一个数组，因为一个属性可能被多个computed所依赖 constructor () &#123; this.deps = [] &#125; depend () &#123; // 此处由依赖的属性收集, 例如 obj.name被obj.info所引用，那个obj.info的监听函数就会自动注册到obj.name的依赖列表上 if (Dep.target &amp;&amp; this.deps.indexOf(Dep.target) === -1) &#123; this.deps.push(Dep.target) &#125; &#125; notify () &#123; // 一旦被依赖的属性发生了变化就会通知依赖的computed属性进行更新 this.deps.forEach(dep =&gt; &#123; dep() &#125;) &#125;&#125;class Observable &#123; constructor (obj) &#123; return this.init(obj) &#125; // 将obj上第一层所有的属性都定义为可观测的，目前只支持对象的递归观测 init (obj) &#123; // 遍历所有的key Object.keys(obj).forEach(key =&gt; &#123; this.defineReactive(obj, key, obj[key]) &#125;); return obj &#125; defineReactive (obj, key, val) &#123; let dep = new Dep(); // 如果值还是一个对象，就机柜观测 if (Object.prototype.toString.call(val) === '[object Object]') &#123; this.init(val) &#125; Object.defineProperty(obj, key, &#123; set (value) &#123; val = value; // 值修改以后通知自己的依赖去更新 dep.notify() &#125;, get () &#123; dep.depend(); return val &#125; &#125;) &#125;&#125;class Watcher &#123; constructor (obj, key, cb, updateFn) &#123; this.obj = obj; this.key = key; this.cb = cb; this.updateFn = updateFn; this.initComputed() &#125; initComputed () &#123; let me = this, // 每次更新需要调用的方法 onComputed = () =&gt; &#123; let val = me.cb.call(me.obj); me.updateFn(val) &#125;; Object.defineProperty(me.obj, me.key, &#123; set () &#123; throw new Error('计算属性不能赋值') &#125;, get () &#123; // 添加依赖，如果存在就不重复添加 Dep.target = onComputed; // 这里会调用依赖的字段的get方法，get方法又会去调用dep.depend()，所以就将这个依赖添加到了列表中 // 使用me.cb.call(me.obj) 这样就可以在cb中使用this获取obj的属性了 let val = me.cb.call(me.obj); // 添加完依赖需要情空 Dep.target = null; return val &#125; &#125;) &#125;&#125;let aaa = new Observable(&#123; name: 'zhangsan', age: 20&#125;);new Watcher(aaa, 'info', function () &#123; return this.name + this.age;&#125;, function (val) &#123; // 只要修改依赖项，info就会更新，也会调用这个方法，在Vue总可以在这里渲染dom了 console.log('new ', val)&#125;) 下面是测试代码1234567// 测试代码console.log(aaa.info);aaa.age = 900;console.log('outer new ', aaa.info)// zhangsan20// new zhangsan900// outer new zhangsan900"},{"title":"使用path的形式获取对象的属性","permalink":"/ckilas0ir00540xqi5kq6wm6s/","text":"我们在开发的过程中，可能会遇到下面的情况，使用一个字符串获取这个对象的某一个值，也许是这样：12345678910111213let a = &#123; name: 'zhangsan', info: &#123; addr: &#123; province: 'prov' &#125;, age: 30 &#125;&#125;;console.log(getDataByPath(a, 'info.addr.province'))// provconsole.log(getDataByPath(a, 'info.addr'))// &#123;province:'prov'&#125; 实现思路就是，将传入的path使用“.”来split，然后循环查找，找不到直接返回一个undefined即可，具体实现如下：1234567891011121314// 此处的实现没有参考angularfunction getDataByPath (data, path) &#123; let arr = path.split('.'), temp = data, i=0, len=arr.length; for (;i&lt;len;i++)&#123; temp = temp[arr[i]]; if (temp === undefined)&#123; break; &#125; &#125; return temp&#125;"},{"title":"解决jquery和$http在ie浏览器url中文乱码的问题","permalink":"/ckilas0jl006r0xqi722l9wdt/","text":"写在前面在ie浏览器中，只要是传递的url后面的中文参数都是乱码的，所以在后台获取的数据并不是我们想要传递的数据，导致数据取不到或者是错误的数据． 解决方案所以下面就针对jquery和angular的$http进行处理，其他框架原理一样的． jquery的实现是调用$.ajaxSetup()设置全局的ajax对象． 12345$.ajaxSetup(&#123; beforeSend: function (xhr, setting) &#123; setting.url = encodeURI(setting.url || ''); // 编码url &#125;&#125;); $http需要用到$httpProvider的拦截器功能，实现如下． 1234567891011angular.module('app', []) // 使用你自己定义的模块.config(function ($httpProvider) &#123; $httpProvider.interceptors.push([function () &#123; return &#123; request: function (req) &#123; req.url = encodeURI(req.url); return req; &#125; &#125;; &#125;]);&#125;)"},{"title":"css中一些实用的方法","permalink":"/ckilas0hd001x0xqi2x3s49nm/","text":"个人在使用的时候用到了一些使用的技巧，就在下面整理了下，不定时更新 禁止一个容器上所有的鼠标事件，例如我们不想删除事件重新注册事件的时候很有用 123.box&#123; pointer-events: none;&#125; 禁止用户选择某个容器下的文本，当然人家要开F12复制，那也是没有办法的，记得加上浏览器前缀，除非你使用了PostCSS或者是autoprefixer 123.box&#123; user-select: none;&#125; 设置非脱离文档流的元素的z-index 1234.box&#123; position: relative; z-index: 10;&#125; 设置高度是屏幕高度，之前都是通过height:100%从上往下元素都写上，可以使用下面的方法 123.box&#123; height: 100vh;&#125; vh是新的单位，就是将屏幕的高度拆分100份，1vh代表1/100窗口高度。 使用多个图片做背景图 123456.box&#123; background: url(../images/bg2.png) no-repeat bottom, url(../images/bg1.png) no-repeat top; background-size: 320px auto;&#125; 修改输入框placeholder的样式，注意所有的前缀都需要写上，要不然怕不会生效 12345678910111213input::-ms-input-placeholder &#123; color: #fff;&#125;input::-webkit-input-placeholder &#123; color: #fff;&#125;input::-moz-input-placeholder &#123; color: #fff;&#125; 7、实用nth-child选中前面n个元素，例如展示进度条的当前进度等 1234/* 选中了前三个元素并且设置背景色为绿色 */:nth-child(-n+3)&#123; background-color: green;&#125;"},{"title":"页面上有两个ztree时出现的问题","permalink":"/ckilas0jp00710xqiqt8bkp6o/","text":"现象今天在页面上使用了两个ztree，分别都是用class实例化的，导致了下面的情况：后面初始化的tree将前面初始化的tree覆盖了，前面初始化的tree只能显示一个根节点，点击无效，但是点击展开，却展开的是第二个tree； 原因ztree初始化的时候会产生一个treeId，treeId是只读的。如果初始化tree的节点没有id属性，这个treeId初始化以后将会是undefined，所以导致了两个tree生成的id是一样的，后面的覆盖前面的。 方案有两个或者多个ztree，渲染的dom上一定要有id属性，防止tree对象出现冲突。"},{"title":"iconfont在chrome中出现锯齿或加粗处理","permalink":"/ckilas0hl002h0xqipao7mjf9/","text":"这是一个神奇的网站：http://www.iconfont.cn/参考地址：http://blog.sina.com.cn/s/blog_6cbbde3f0102vw2s.html 使用阿里的iconfont在chrome中出现了毛边锯齿的问题，解决方案123456/*这个值的大小可以在浏览器中调整查看结果*/.iconfont&#123; -webkit-text-stroke-width:2px; /*加粗的情况可以使用下面的代码处理，iconfont已经处理了*/ -webkit-font-smoothing: antialiased;&#125;"},{"title":"Javascript加载优化技巧","permalink":"/ckilas0ho002o0xqiyw5j6emf/","text":"参考了&lt;&lt;高性能javascript&gt;&gt;,看了下面的技巧 减少script标签的数量（减少请求的数目）将script标签放在body下面，防止阻止页面渲染动态脚本，在javascript中使用代码创建script节点 动态脚本主要有下面的实现方式：使用创建script标签然后使用的方式，实现如下12345678910111213141516var sc = document.createElement('script');sc.type = \"text/javascript\";sc.src = \"file1.js\";if (sc.readyState)&#123; // IE的回调 sc.onreadystatechange = function () &#123; if (sc.readyState === 'loaded' || sc.readyState === 'complete')&#123; sc.onreadystatechange = null; // 清理引用 alert('loaded') &#125; &#125;&#125;else&#123; sc.onload = function () &#123; alert('loaded') &#125;&#125;document.getElementsByName('head')[0].appendChild(sc); 使用XMLHttpRequest注入脚本，实现如下1234567891011121314// 使用的原理是将js代码请求过来加到内链的script上// 只有追加在head才会执行var xhr = new XMLHttpRequest();xhr.open('get', 'file1.js', true);xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4)&#123; if (xhr.status &gt;=200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304)&#123; var sc = document.createElement('script'); sc.type = 'text/javascript'; sc.text = xhr.responseText; document.getElementsByName('head')[0].appendChild(sc); &#125; &#125;&#125;"},{"title":"在Vue生成的项目中添加eslint全局规则","permalink":"/ckilas0j6005s0xqiwidju27m/","text":"在Vue-cli生成的项目中会自带eslint插件来校验代码，有时候我们需要加入全局的$插件，就是在模块中不引入$就可以使用；简单的方法就是，创建一个模块如下123import $ from 'jquery'$.test = 'message test'window.$ = $ 在项目的入口处导入这个模块就全局引入了，但是在别的模块中不通过import $ from &#39;jquery&#39;使用$就会报错，提示$没有定义，所以我们需要配置下eslint的配置。修改.eslintrc.js文件，添加globals节点，修改结果如下，注意注释部分，配置参考http://eslint.org/docs/user-guide/configuring12345678910111213141516171819202122module.exports = &#123; root: true, parser: 'babel-eslint', parserOptions: &#123; sourceType: 'module' &#125;, env: &#123; browser: true &#125;, extends: 'standard', plugins: [ 'html' ], // 加入全局的检查，遇到$的时候不会报没有定义 globals: &#123; $: true &#125;, rules: &#123; 'arrow-parens': 0, 'generator-star-spacing': 0 &#125;&#125;"},{"title":"使用Vue动态加载组件和路由","permalink":"/ckilas0ih004j0xqiryrau7mg/","text":"在我们开发Vue项目的过程中，架构一般都会设计为SPA，如果所有的组件和路由都加载，打包后的文件会达到几兆或者几十兆。 对于网络快的用户倒是无所谓了，但是还有很大的一部分用户的网络并不理想，这就导致首次加载页面的时候花费的时间很长，导致用户没有继续访问的欲望。所以在我们的项目中用了按需加载的方式加载组件和路由。 技术实现主框架：Vue2打包工具：Webpack路由工具：Vue-router 下面就先演示下怎么异步加载一个组件http://cn.vuejs.org/v2/guide/components.html#异步组件123456789101112131415// 因为是都会用到的组件，所以就挂载到全局上面// Vue.component接受一个promise对象，通过webpack内置的require动态加载一个组件，只用使用的时候才会去加载Vue.component('Navbar', resolve =&gt; &#123; require(['@/components/Navbar.vue'], resolve)&#125;)Vue.component('Pagination', resolve =&gt; &#123; require(['@/components/Pagination.vue'], resolve)&#125;)Vue.component('AppItem', resolve =&gt; &#123; require(['@/components/AppItem.vue'], resolve)&#125;)// 下面使用es2015的形式创建一个异步组件Vue.component( 'AppItem', () =&gt; import('@/components/AppItem.vue')) 下面是Vue-router加载一个异步的模块,详细: http://router.vuejs.org/zh-cn/advanced/lazy-loading.html12345678910export default new Router(&#123; routes: [&#123; path: '/appsearch', name: 'appsearch', // 这里和Vue中使用的一致的 component (resolve) &#123; require(['@/pages/AppSearch.vue'], resolve) &#125; &#125;]&#125;)"},{"title":"flexbox左右布局宽度固定","permalink":"/ckilas0hh00270xqihdbixo5t/","text":"flex盒子我在使用的时候发现一个问题，左侧宽度一定，右边自适应，但是右边内容过大的时候就会把左边的部分变小,需要设置下面的属性 123456789.item&#123; flex-shrink: 0; // TODO 即使空间不够也不缩小,默认是1&#125;//或者.item-flex1 &#123; flex-grow: 1; overflow: hidden;&#125;"},{"title":"在CentOS6上安装mysql5.6并开启远程登录","permalink":"/ckilas0fx00020xqi6hn9w2m7/","text":"CentOS6库里面是mysql 5.1,由于mysql 5.1有乱码的问题和工作需要,在网上查询资料进行安装mysql5.6 1、 下载对应的仓库1wget dev.mysql.com/get/mysql-community-release-el6-5.noarch.rpm 2、 安装下载好的仓库123456 yum install mysql-community-release-el6-5.noarch.rpm yum repolist enabled | grep mysql # mysql-connectors-community MySQL Connectors Community 42# mysql-tools-community MySQL Tools Community 36# mysql56-community MySQL 5.6 Community Server 227 3、 安装mysql5.6 1yum install mysql-community-server 4、 设置密码123/usr/bin/mysqladmin -u root password 'admin'/usr/bin/mysqladmin -u root -h linux32 password 'admin'/usr/bin/mysqladmin -u root -h localhost password 'admin' 5、设置远程登录1234# 授权所有的权限给root和任意host(%)，密码是adminmysql&gt; grant all privileges on *.* to root@\"%\" identified by \"admin\";# 刷新权限；或者退出重启mysql服务mysql&gt; flush privileges 使用其他的客户机使用sqlyog等客户端就可以连接了 Link: http://www.cnblogs.com/lzj0218/p/5724446.html"},{"title":"mui消息推送并且显示角标","permalink":"/ckilas0i7003y0xqi3wawe31i/","text":"12345678910mui.plusReady(function() &#123; // 推送消息 plus.push.createMessage(msg.msg, null, &#123; title: msg.title &#125;); // 清空消息 plus.push.clear(); // 设置角标(设置角标的时候先把plus.push.clear了，否则会一直叠加上去的) plus.runtime.setBadgeNumber(count);&#125;);"},{"title":"websql在ios平台上查询出来取值为null","permalink":"/ckilas0ic00480xqi1mjwr9lk/","text":"做过移动项目的同学都知道，为了加快app的运行速度，许多静态的数据可以存储在本地的websql中，今天我就遇到一个问题： websql 查出来的数据在安卓系统上可以正常的显示，但是在IOS上却显示的全是NULL 究其原因，通过自己不懈努力的百度和ding先生的帮助，终于知道，ios上和安卓上存储的结构有所不同，下面是一个查询函数 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 处理参数，例如 &#123;name:'zhangsan',age:56&#125; =&gt; \" where 1=1 and name='zhangsan' and age=56\" * @param params * @returns &#123;&#123;append: string, fill: Array&#125;&#125; */function resolveCondition(params) &#123; var paramArr = [], append = ' where 1=1'; Object.keys(params).forEach(function (key) &#123; paramArr.push(params[key]); append += ' and ' + key + '=?'; &#125;); return &#123; append: append, fill: paramArr &#125;;&#125;/*** @param params 查询参数，* @param callback 回调函数*/function query(params, callback) &#123; var me = this, condition = resolveCondition(params); // 处理条件 var sql = 'select * from ' + me.tableName + condition.append; // 拼接sql语句 // 执行查询 db.transaction(function (tx) &#123; tx.executeSql(sql, condition.fill, function (tx, res) &#123; // res.rows是一个类数组对象，有length属性 // 在android上可以使用[].slice.call(res.rows)转化成真正的数组，数据能正常显示 // 在ios也可以使用[].slice.call(res.rows)转化成真正的数组，但是所有的项都是null // 这个类数组对象有一个item(index)方法,可以根据下标来获取数据，兼容安卓和IOS，所以就出现了下面的解决方法 var length = res.rows.length, result = []; for (var i = 0; i &lt; length; i++) &#123; result.push(res.rows.item(i)); &#125; callback &amp;&amp; callback(0, result); &#125;, function () &#123; callback &amp;&amp; callback(1, 'query error'); &#125;); &#125;);&#125; 下面是解决方案的描述 res.rows是一个类数组对象，有length属性 在android上可以使用[].slice.call(res.rows)转化成真正的数组，数据能正常显示 在ios也可以使用[].slice.call(res.rows)转化成真正的数组，但是所有的项都是null 这个类数组对象有一个item(index)方法,可以根据下标来获取数据，兼容安卓和IOS，所以使用item取数据"},{"title":"理解Function的bind,apply,call方法","permalink":"/ckilas0jj006n0xqiqn431ype/","text":"简单来说，call、apply、bind都是改变函数执行上下文，也就是this的指向。 先说一下他们的相同点： 1、 调用方式，都是通过functionName.[call|apply|bind]调用的。2、 作用，都是为了修改函数的执行上下文，也就是this对象。3、 都是Function对象内置的方法。 下面说一下不同点吧： 1、 apply和call改变function的执行上下文并且执行这个函数。2、 bind不改变原函数的上下文，但是返回一个新的函数，新函数的执行上下文就是bind指定的对象。 123456789var name = 'zhangsan';var obj = &#123;name: 'lisi'&#125;;function say() &#123; console.log(this.name);&#125;say(); // zhangsansay.call(obj); // lisi ，只改变执行上下文say.apply(obj); // lisi ， 只改变执行上下文say.bind(obj)(); // lisi ， bind会产生一个新的函数，this指向的是obj ,想得到结果就需要再执行一下 下面说一下apply和call的不同之处： 1、 apply传参数的形式是，apply(scope,argumentArray);2、 call传递参数的形式是，call(scope,arg1,arg2,arg3…) 可以看出apply除了作用域，其他参数的形式是以类数组的形式传递，call是按照顺序的传递的。123456789101112131415161718192021222324var arr = [9,6,3,2,5,8,1];// 求上面数组的最大值有下面的方式Math.max.call(null,9,6,3,2,5,8,1);Math.max(9,6,3,2,5,8,1);Math.max.apply(null,arr);// 上面的三种方式，第一种第二种不适合数组求最大值,apply方法就轻而易举的解决了这个问题// 所以，目前个人总结：明确参数个数的可以使用call调用,不明确参数个数的可以使用apply，例如下面使用方式function User(name,age) &#123; this.name = name; this.age = age;&#125;// 下面也是通过call和apply实现集成的方法function SubUser(name,age) &#123; // 固定有两个参数，如果User方法添加了新的参数，就需要修改这个方法 User.call(this,name,age);&#125;function SubUser2() &#123; // 在这里，我们按照User的顺序去执行方法，也就是User的参数修改了，我们这里不用修改 // 不管User方法的参数怎么修改，只要调用SubUser2的参数顺序和User的保持一致就好了 User.apply(this,arguments);&#125; bind参数部分和call有些类似，bind第一个参数是上下文，剩余的参数会传递到新函数参数的首部，例如 12345678910111213const user = &#123; name: 'zhangsan', age: 80&#125;;function say(name)&#123; console.log(name, this.name, this.age);&#125;const say2 = say.bind(user, 'lisi');say2(); // lisi zhangsan 80// 我们发现把lisi传到了参数里面，这个是个传递额外的参数"},{"title":"mui框架在echarts页面子页面返回导致图空白","permalink":"/ckilas0i6003v0xqitow5qw77/","text":"在使用mui进行开发的时候，echarts出现了下面的情况： 在存在echart的页面点击跳转到新的页面，再回退回来的时候echarts就不显示了，除非点一下响应区域（点击有效果的地方） 下面是一个很简单粗暴的方案，后期如果有新的好的方案，请回复此贴。1、首先在echarts的页面加上事件的监听，执行echarts的resize操作JS部分123window.addEventListener('goback', function() &#123; vm.$refs.line.resize(); // 在这里 此处的VM是vue的实例 line是组件的依赖&#125;); HTML部分12&lt;!--添加ref属性可以在vm.$refs中调用到--&gt;&lt;chart ref=\"line\" :options=\"opts\"&gt;&lt;/chart&gt; 2、在进入的页面上加上返回回调12345678$.init(&#123; beforeback: function() &#123; // 通知有echarts的页面触发返回事件，下面就通知了两个页面，分别是xxx.html和xxx2.html // 其中xxx.html和xxx2.html是页面的id $.fire(plus.webview.getWebviewById('xxx.html'), 'goback'); $.fire(plus.webview.getWebviewById('xxx2.html'), 'goback'); &#125;&#125;);"},{"title":"js实现快速排序","permalink":"/ckilas0hq002s0xqivqxircjr/","text":"参考：http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html“快速排序”的思想很简单，整个排序过程只需要三步（1）在数据集之中，选择一个元素作为”基准”（pivot）。（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 下面是代码实现：123456789101112131415var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); // 获取基准的坐标 var pivot = arr.splice(pivotIndex, 1)[0]; // 获取基准值 var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;;"},{"title":"让图片和文本在div中居中","permalink":"/ckilas0jm006u0xqirkb3e4fy/","text":"很多时候我们会有下面的结构，但是图片和文本总是不居中的CSS代码：1234567.middle&#123; line-height: 30px;&#125;.middle img&#123; height: 20px; width: 20px;&#125; HTML代码123&lt;div class=\"middle\"&gt; &lt;img src=\"abc.png\"&gt; 这是一张图片的简介&lt;/div&gt; 解决方案1：给img做垂直居中12345.middle img&#123; height: 20px; width: 20px; vertical-align: middle;&#125; 解决方案2：使用flex布局（但是老的浏览器可能不支持）1234.middle&#123; display: flex; align-items: center;&#125;"},{"title":"js实现折半查找算法","permalink":"/ckilas0hr002v0xqi27q51s7k/","text":"二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。查找过程可以分为以下步骤（1）首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。（2）如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。（3）如果某一步数组为空，则表示找不到目标元素。 下面是代码实现：123456789101112131415161718192021222324252627282930313233// 非递归算法function binary_search(arr, key) &#123; var low = 0, high = arr.length - 1; while(low &lt;= high)&#123; var mid = parseInt((high + low) / 2); if(key === arr[mid])&#123; return mid; &#125;else if(key &gt; arr[mid])&#123; low = mid + 1; &#125;else if(key &lt; arr[mid])&#123; high = mid -1; &#125;else&#123; return -1; &#125; &#125;&#125;; // 递归算法function binary_search2(arr,low, high, key) &#123; if (low &gt; high)&#123; return -1; &#125; var mid = parseInt((high + low) / 2); if(arr[mid] === key)&#123; return mid; &#125;else if (arr[mid] &gt; key)&#123; high = mid - 1; return binary_search(arr, low, high, key); &#125;else if (arr[mid] &lt; key)&#123; low = mid + 1; return binary_search(arr, low, high, key); &#125;&#125;;"},{"title":"Ubuntu中使用命令行连接wifi网络","permalink":"/ckilas0h6001l0xqilcpk4yq6/","text":"如果你使用的Ubuntu Server或者是像我一样的手欠，把桌面环境搞挂了，但是由没有网线可以上网恢复，但是有无线网可以使用，可以跟着下面做 1、 在Ubuntu中网络连接是NetworkManager代理的，所以我们先关闭NetworkManager服务，Server版本直接跳过1sudo service network-manager stop 2、 先检查无线网卡有没有开启12345678lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (本地环回) RX packets 10972 bytes 1590822 (1.5 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 10972 bytes 1590822 (1.5 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 我们只看到一条lo记录，那就说明我们没有开启无线网卡，使用以下任意一个命令开启，此处就wlan0举例123ifup wlan0ifconfig wlan0 upiwconfig wlan0 txpower on 执行完上面的命令继续使用ifconfig查看网卡，显示如下123456789101112131415lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (本地环回) RX packets 11344 bytes 2088766 (2.0 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 11344 bytes 2088766 (2.0 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0wlan0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 ether 9a:c5:f9:25:0d:05 txqueuelen 1000 (以太网) RX packets 1359035 bytes 1853939996 (1.8 GB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 949865 bytes 95687031 (95.6 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 我们已经看到了wlan0，说明启动无线网卡成功了。3、 下面我们扫描所有的WiFi，找到我们需要连接的Wifi就可以连接了123456789iwlist wlan0 scan | grep ESSID # 查询所有可用的SSIDESSID:\"we are family\"ESSID:\"fengyingdongdong\"ESSID:\"HOME403\"ESSID:\"CMCC-LuF6\"ESSID:\"CMCC-5Gem\"ESSID:\"wuxian\"ESSID:\"TP-LINK_F6F6\"ESSID:\"Xiaomi_whp\" 4、 我们已经得到了所有的wifi列表，就以wuxian为例子连接一下12wpa_passphrase wuxian &gt; wifi.conf # 回车后输入密码，继续回车就会生成配置文件，这一步为了将我们的密码转化成系统能识别的密码wpa_supplicant -iwlan0 -cwifi.conf -B # -B 后台运行 -i 选择网卡 -c 选择配置文件 5、 我们需要配置一下dhcp获取IP地址12dhclient -rdhclient wlan0 # wlan0是网卡的名字，不是随便乱写的，和上面的保持一致 6、 完成了上面的步骤，先试试能不能上网，如果不能上网，那应该是dns的问题，所以进一步配置dns12vim /etc/resolv.conf # 加上一行nameserver 192.168.2.1 # 后面的ip根据你的应用场景而定，路由器一般是192.168.0.1,192.168.2.1,192.168.1.1 现在试一下，就可以上网了，测试能不能上网很简单 ping www.baidu.com 如果有响应，那就是可以上网了，响应：12345678PING www.a.shifen.com (119.75.216.20) 56(84) bytes of data.64 bytes from 119.75.216.20: icmp_seq=1 ttl=56 time=23.6 ms64 bytes from 119.75.216.20: icmp_seq=2 ttl=56 time=190 ms64 bytes from 119.75.216.20: icmp_seq=3 ttl=56 time=39.9 ms64 bytes from 119.75.216.20: icmp_seq=4 ttl=56 time=8.03 ms64 bytes from 119.75.216.20: icmp_seq=5 ttl=56 time=4.86 ms64 bytes from 119.75.216.20: icmp_seq=6 ttl=56 time=11.8 ms64 bytes from 119.75.216.20: icmp_seq=7 ttl=56 time=8.44 ms"},{"title":"使用js实现斐波那契数列","permalink":"/ckilas0in004x0xqibm8bxoqv/","text":"使用js实现斐波那契数列,生成的数组如下所示 [ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233 ] 从上面的数组我们看出了规律,第一个和第二个是固定的,分别是0和1,后面的数就是前面的数之和。实现方式主要有下面的两种方式，第一种是递归的方式实现：123456789/*** @param n 数组的第几个数*/function fibonacci(n) &#123; if (n === 1 || n === 2) &#123; return n - 1; &#125; return fibonacci(n - 1) + fibonacci(n - 2);&#125; 下面使用的第二种方式，使用递推的方式实现1234567891011121314151617/*** @param n 数组的第几个数*/function fibonacci(n) &#123; if (n === 1 || n === 2) &#123; return n - 1; &#125; let n1 = 0, n2 = 1, sn = 0; for (let i = 0; i &lt; n - 2; i++) &#123; sn = n1 + n2; // 计算本次的 n1 = n2; // 第一个值用第二个值替换 n2 = sn; // 第二个为本次计算的值 // n=3 =&gt; sn=0+1 =&gt; n1=1 =&gt; n2=1 // n=4 =&gt; sn=1+1 =&gt; n1=1 =&gt; n2=2 &#125; return sn;&#125; 生成长度为10的斐波那契数组123456let i = 1, arr = [];while (i &lt; 15) &#123; arr.push(fibonacci(i++));&#125;console.log(arr);// result [ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233 ]"},{"title":"基于Maven搭建一个SpringMVC的项目","permalink":"/ckilas0j9005z0xqi74eimxxj/","text":"最近公司需要开发一个API文档管理系统，又捡起来好久不见的Java（PS：本人现在是一个前端程序员），由于之前使用Java开发过项目，所以打算基于SpringMVC进行开发。 项目使用的技术： SpringMVC + MySQL + Gson + Proxool + Vue 本文的依赖环境（如果没有安装，请自行百度安装）：12Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)Java version: 1.8.0_121, vendor: Oracle Corporation 本文主要记载基于Maven的SpringMVC项目的搭建，本文使用的开发环境是IntelliJ IDEA，下文中称之为IDEA，是目前用的比较火的一个工具，开发效率很高。 主要分为下面几步完成 使用IDEA创建一个项目 在pom.xml中添加依赖 添加数据库配置文件 添加spring配置文件 添加springMVC配置文件 修改web.xml配置spring 创建一个controller 使用IDEA创建一个项目1、创建Maven项目，选择webapp模板 2、填写项目对应的信息，一路回车就好了 查看生成的目录，没有java源目录，需要手动创建123456789├── pom.xml├── src│ └── main│ ├── resources│ └── webapp│ ├── index.jsp│ └── WEB-INF│ └── web.xml└── workstore.iml 在pom.xml中添加依赖本项目是基于springmvc进行开发的，下面是pom.xml的完整配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.webrepos&lt;/groupId&gt; &lt;artifactId&gt;workstore&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;workstore Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 连接mysql必须加载的 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.29&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springmvc核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;3.2.17.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;3.2.17.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- proxool连接池，可能在maven仓库的是0.8的，这就需要手动下载jar包，放在本地 --&gt; &lt;dependency&gt; &lt;groupId&gt;proxool&lt;/groupId&gt; &lt;artifactId&gt;proxool&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 必须的，否则会出错 --&gt; &lt;dependency&gt; &lt;groupId&gt;proxool&lt;/groupId&gt; &lt;artifactId&gt;proxool-cglib&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- javaee必须的 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- json响应支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- google json工具库，提供解析json等功能 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;workstore&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 添加数据库配置文件本项目采用proxool数据库连接池，所以在resources下创建jdbc.properties，内容如下1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/webstorejdbc.username=rootjdbc.password=admin 添加spring配置文件在resources创建一个spring.xml，内容如下12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 加载jdbc配置文件 --&gt; &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Proxool连接池，使用jdbc配置文件注入 --&gt; &lt;bean id=\"dataSource\" class=\"org.logicalcobwebs.proxool.ProxoolDataSource\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"driverUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 配置spring提供的jdbcTemplate工具，进行数据库的操作 --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"queryTimeout\" value=\"300000\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 添加springMVC配置文件在resources创建一个spring-mvc.xml，内容如下123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;mvc:resources mapping=\"/app/**\" location=\"/static/\"/&gt; &lt;!--不处理静态资源--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--开启注解--&gt; &lt;mvc:annotation-driven/&gt; &lt;context:component-scan base-package=\"com.webrepos.workstore\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Service\"/&gt; &lt;/context:component-scan&gt; &lt;!--JSON支持--&gt; &lt;bean class=\"org.springframework.web.servlet.view.ContentNegotiatingViewResolver\"&gt; &lt;property name=\"order\" value=\"1\"/&gt; &lt;property name=\"defaultViews\"&gt; &lt;list&gt; &lt;bean class=\"org.springframework.web.servlet.view.json.MappingJackson2JsonView\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 修改web.xml配置spring上面的步骤已经创建了spring.xml和spring-mvc.xml，现在项目中启用12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 初始化spring --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置spring-mvc默认的servlet = DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodeFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodeFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 创建一个controller由于初始化的时候没有java的源文件目录,所以需要手动的添加目录,在main下面创建java目录,右键设置为源码目录,操作: Mark Directory as =&gt; Source Root 在java目录下创建一个包,名为com.webrepos.workstore.controller,在该包下创建一个HelloController,将下面的代码粘贴进去123456789101112package com.webrepos.workstore.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller(\"/\")public class HelloController &#123; @RequestMapping(\"/test\") @ResponseBody public String test() &#123; return \"hello world\"; &#125;&#125; 部署在tomcat,然后启动tomcat,在浏览器输入:http://localhost:8080/test,就能看到hello world了 一个完整的应用就搭建起来了．后面会加入mybatis的相关配置"},{"title":"使用vue封装一个简单echarts组件","permalink":"/ckilas0iv005e0xqip68a0u2r/","text":"支持的功能：1、 数据监听刷新echarts图2、 外部方法调用,主要是通过vue实例的$refs调用3、 垃圾回收，页面销毁自动清理添加的变量 使用方法：1234&lt;div style=\"height: 300px;\"&gt; &lt;!--opts是echarts的配置，详情请查看echarts官方网站（echarts.baidu.com）--&gt; &lt;chart :options=\"opts\"&gt;&lt;/chart&gt;&lt;/div&gt; 主要代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111(function(window) &#123; var $ = window.$, Vue = window.Vue, echarts = window.echarts; // 设置默认的宽度和高度 var size = &#123; height: '100%', width: '100%' &#125;; // 设置默认的options var defaults = &#123; tooltip: &#123; show: false &#125;, toolbox: &#123; show: false &#125; &#125;; // 设置可触发的事件 var events = [ 'click', 'dblclick', 'mouseover', 'mouseout', 'mousedown', 'mouseup', 'globalout' ]; // 设置可执行的方法 var methods = [ 'dispatchAction', 'showLoading', 'hideLoading', 'getWidth', 'getHeight', 'getOption', 'clear', 'resize' ]; // 主要的配置参数 var factory = &#123; props: ['options', 'width', 'height'], template: '&lt;div&gt;&lt;/div&gt;', data: function() &#123; return &#123; chart: null, _resize: null &#125;; &#125;, mounted: function() &#123; if(this.options) &#123; this._init(); &#125; &#125;, watch: &#123; options: &#123; handler: function(options) &#123; if(!this.chart &amp;&amp; options) &#123; this._init() &#125; else &#123; setTimeout(function() &#123; this.chart.setOption($.extend(true, &#123;&#125;, defaults, this.options), true); &#125;.bind(this)); &#125; &#125;, deep: true &#125; &#125;, methods: &#123; _init: function() &#123; if(this.chart) return; var me = this; this.$el.style.width = this.width || size.width; this.$el.style.height = this.height || size.height; var chart = echarts.init(this.$el); // 初始化echarts组件 chart.setOption($.extend(true, &#123;&#125;, defaults, this.options), true); // 添加随着窗口变化自动监听 this._resize = chart.resize; window.addEventListener('resize', this._resize); // 添加事件 events.forEach(function(e) &#123; chart.on(e, function(params) &#123; me.$emit(e, params); &#125;); &#125;); // 挂载chart this.chart = chart; &#125; &#125;, /** * 组件销毁的时候处理变量和事件 */ beforeDestroy: function() &#123; if(!this.chart) return; window.removeEventListener('resize', this._resize); this.chart.dispose(); this.chart = null; this._resize = null; &#125; &#125;; /** * 添加echarts的方法 */ methods.forEach(function(m) &#123; factory.methods[m] = function() &#123; return this.chart[m].apply(this.chart, [].slice.apply(arguments)); &#125;; &#125;); // 全局注册组件，可以使用标签的形式引入 Vue.component('chart', factory);&#125;)(window);"},{"title":"使用js将秒转化为\"天时分秒\"的时长形式","permalink":"/ckilas0io00500xqiq6wkz0zy/","text":"现在有这样一个需求，后台存储的使用时长时秒为单位，我们需要转化成下面的形式 100 =&gt; 1分40秒3611 =&gt; 1小时0分11秒… 所以我就编写了下面的函数进行转化，功能实现了，但是还待优化1234567891011121314151617181920212223function convert(input) &#123; input = Number(input); var d = Math.floor(input / (3600 * 24)), h = Math.floor((input % (3600 * 24)) / 3600), m = Math.floor((input % 3600) / 60), s = (input % 60), result = ''; if (d) &#123; result += d + '天'; &#125; if (h) &#123; result += h + '时'; &#125; if (m) &#123; result += m + '分'; &#125; result += s + '秒'; return result;&#125;convert(1000); // 16分40秒convert(56); // 56秒convert(562547); // 6天12时15分47秒"},{"title":"js获取最近一周的时间","permalink":"/ckilas0hu00330xqihsjr9ply/","text":"JavaScript中时间的表现形式有:Number,String,Date,都可以使用new Date()转化成标准的Date类型. 下面我介绍一种Number类型时间的计算方式,Number类型的时间是以毫秒的形式存储的,换算如下:12341s = 1000ms // 1秒=1000毫秒1m = 60s // 1分钟=60秒1h = 60m // 1小时=60秒1d = 24h // 1天=24小时 由上面的规则可以得出:11d = 24 * 60 * 60 * 1000ms 下面就是实现最近一周时间的一个方法:123456789/** * 获取最近一周的时间 */function nearOneWeek() &#123; var now = +new Date(); return [7, 6, 5, 4, 3, 2, 1].map(function (p1) &#123; return formatDate(now - (p1 * 24 * 60 * 60 * 1000), 'M-d'); &#125;);&#125; 上文中有一个formatDate方法,请点击这里查看."},{"title":"使用js写一个日期格式化函数","permalink":"/ckilas0il004t0xqi844oxihv/","text":"有时候我们需要对时间做一下格式化,例如:12Wed May 03 2017 22:33:22 GMT+0800 (CST) =&gt; 2017/05/031493822039042 =&gt; 2017/05/03 22:33 下面我们就定制一个可以格式化时间的函数123456789101112131415161718192021222324/** * @description 不满两位的填充0 * @param v * @returns &#123;string&#125; */function fillStr(v) &#123; return v &lt; 10 ? '0' + v : v;&#125;/** * 格式化时间 * @param d 时间 * @param patten 格式文本 y 年；M 月；d 日；H 小时；m 分钟；s 秒； * @returns &#123;string&#125; 格式化以后的实践 */function formatDate(d, patten) &#123; patten = patten || 'y-M-d H:m:s'; var date = d ? new Date(d) : new Date(); return patten.replace(/y/g, date.getFullYear()) .replace(/M/g, fillStr(date.getMonth() + 1)) .replace(/d/g, fillStr(date.getDate())) .replace(/H/g, fillStr(date.getHours())) .replace(/m/g, fillStr(date.getMinutes())) .replace(/s/g, fillStr(date.getSeconds()));&#125; 下面是使用方法和返回的结果123// usageformatDate(new Date(),'y年M月d日'); // 2017年05月03日formatDate(new Date()); // 2017-05-03 22:47:56"},{"title":"动态加载js和css文件，抽时间优化","permalink":"/ckilas0j3005l0xqifbra5rfe/","text":"其实下面就做了一个类似require.js的实现； 有的场景我们需要把一些库封装起来，对外提供一个名字去加载，这样做的目的就是将库和页面分开，页面不直接依赖于库的某一个文件，只需要知道库的名字就可以了； 1、 首先我们需要定义一个库对应的js和css文件123456789101112var libs = &#123; echarts: &#123; js: ['js/libs/echarts.min.js', 'js/echarts-utils.js'] &#125;, picker: &#123; js: ['js/libs/mui.picker.js', 'js/libs/mui.poppicker.js'], css: ['css/mui.picker.css', 'css/mui.poppicker.css'] &#125;, sceneHeader: &#123; js: ['js/element/scene-header.js'] &#125;&#125;; 2、 接下来我们写一个加载js和css的方法，这里js需要同步加载，否则会导致依赖不全12345678910111213141516171819202122232425262728293031323334/** * 加载js文件 * @param name 文件的名字，其实叫url更加合适 * @param callback 回调函数，不管是否加载成功都会处理回调，作用是计数 */function addJScript(name, callback) &#123; var sc = document.createElement('script'); sc.type = \"text/javascript\"; sc.src = name; sc.async = false; // 异步加载关闭 sc.addEventListener('load', callback || $.noop, false); sc.addEventListener('error', function () &#123; console.log('[DEBUG] ' + name + '加载失败。'); callback &amp;&amp; callback(); &#125;, false); document.querySelector('head').appendChild(sc);&#125;/** * 加载css文件 * @param name 文件的名字，其实叫url更加合适 * @param callback 回调函数，不管是否加载成功都会处理回调，作用是计数 */function addCss(name, callback) &#123; var link = document.createElement('link'); link.rel = \"stylesheet\"; link.href = name; link.addEventListener('load', callback || $.noop, false); link.addEventListener('error', function () &#123; callback &amp;&amp; callback(); // callback计数 console.log('[DEBUG] ' + name + '加载失败。'); &#125;, false); document.querySelector('head').appendChild(link);&#125; 3、 最后我们定义加载库的方法，我这里直接挂在$对象上的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @description 获取文件网页根目录 * @returns &#123;*&#125; */function getRoot() &#123; return window.location.href.split('dist/')[0];&#125;/** * @description 加载组件库 * @param &#123;Object&#125; libName * @param callback 加载完成的回调函数 */$.loadLib = function (libName, callback) &#123; var libNames = Array.isArray(libName) ? libName : [libName]; // 将所有的库转化成数组 var fileCount = 0; // 所有库的文件数量 var loadedFileCount = 0; // 已经加载的文件数量 libNames.forEach(function (name) &#123; var lib = libs[name]; if (lib) &#123; fileCount += (lib.js || []).concat(lib.css || []).length; &#125; else &#123; throw new Error('没有找到名为的\"' + libName + '\"库，目前支持的库：' + Object.keys(libs).join(',')); &#125; &#125;); /** * 加载完成才会处理回调函数 */ function loaded() &#123; loadedFileCount++; if (loadedFileCount === fileCount) &#123; callback &amp;&amp; callback(); &#125; &#125; /** * 加载所有的库 */ libNames.forEach(function (name) &#123; var lib = libs[name]; if (lib) &#123; // 先加载js文件,再加载css文件 (lib.js || []).forEach(function (s) &#123; addJScript(getRoot() + s, loaded); &#125;); (lib.css || []).forEach(function (c) &#123; addCss(getRoot() + c, loaded); &#125;); &#125; else &#123; throw new Error('没有找到名为的\"' + libName + '\"库，目前支持的库：' + Object.keys(libs).join(',')); &#125; &#125;);&#125;; 4、 下面是我们使用的例子123$.loadLib('echarts',function() &#123; // 在这里使用就可以了&#125;);"},{"title":"mui中使用vue遇到的各种问题","permalink":"/ckilas0i4003q0xqir4fyzqrp/","text":"1、 把mui.init写到vue程序的mounted钩子上. 因为vue代理了dom，dom没有初始化，所以mui.init的时候没有找到dom，就没有效果。 2、 定义vue组件时，所有的属性必须是小写. 组件中定义的属性是 aaBb 在标签上绑定的时候使用 aa-bb绑定，如果显示小写就是全小写 3、 mui的下拉刷新在当出现以下布局的时候就不能使用。12345678910111213141516&lt;style type=\"text/css\"&gt; .mui-pull-top-pocket &#123; top: 40px !important; &#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;header class=\"mui-bar mui-bar-nav\"&gt; &lt;a class=\"mui-action-back mui-icon mui-icon-left-nav mui-pull-left\"&gt;&lt;/a&gt; &lt;h1 class=\"mui-title\" v-text=\"$t('title')\"&gt;&lt;/h1&gt; &lt;/header&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el:'#app'&#125;);&lt;/script&gt;"},{"title":"Ubuntu提示\"您的当前网络有.local域,网络服务探测被禁用\"","permalink":"/ckilas0ha001r0xqi0rayoqqa/","text":"修改/etc/default/avahi-daemon 1sudo vim /etc/default/avahi-daemon 修改下面的内容12# AVAHI_DAEMON_DETECT_LOCAL=1AVAHI_DAEMON_DETECT_LOCAL=0"},{"title":"Sublime Text在Ubuntu下不能输入中文","permalink":"/ckilas0h5001g0xqi1ethn3m8/","text":"在Ubuntu下安装了fcitx和搜狗输入法不能输入中文，下面是解决方案。 下载代码：1git clone https://github.com/gslnzfq/sublime-chinese.git 代码结构是：12345678- bin - subl # sublime的命令行快捷方式 - sublime_text.desktop # sublime 的桌面快捷方式- lib - libsublime-imfix.so # 编译后的共享库- src - sublime_imfix.c # c代码，使用build.sh 编译到libsublime-imfix.so- build.sh # 编译脚本，sublime_imfix.c =&gt; libsublime-imfix.so 操作：1、 首先需要安装C++的编译环境，如果安装了就可以跳过，如果使用已经编译好的libsublime-imfix.so文件，也可以直接跳过了。12sudo apt-get install build-essentialsudo apt-get install libgtk2.0-dev 2、 编译共享库到lib文件夹，如果使用已经编译好的libsublime-imfix.so文件，也可以直接跳过了。1bash build.sh # 执行完成后lib/libsublime-imfix.so就是重新编译后的库 3、 复制共享库libsublime-imfix.so到 /opt/sublime_text1sudo cp ./lib/libsublime-imfix.so /opt/sublime_text 4、 将bin/subl 复制到 /usr/bin下面12# 在命令行执行subl就可以输入中文了sudo cp ./bin/subl /usr/bin 5、 让快捷方式打开也能输入中文，复制sublime_text.desktop到/usr/share/applications12# 使用快捷方式打开也可以输入中文了sudo cp ./bin/sublime_text.desktop /usr/share/applications 6、 如果sublime_text快捷方式还是输入不了中文，请检查是否有其他的快捷方式并删除12rm ~/.local/share/applications/sublime_text.desktop# 就可以删除中文了"},{"title":"Java中List数据高效对比筛选","permalink":"/ckilas0gn000p0xqiwvzvplku/","text":"在实际的开发中，经常会晕倒这样的问题，有两个List的数据，需要对这两个List的数据进行对比，然后筛选出需要的对象。 例如：财务中的对账,数据源一个是银行日记账（aList），一个是银行对帐单（bList），业务操作就是把两个List里面金额相同的记录筛选掉，剩下金额不相等的。 在实际开发中我目前知道有两个方式（假设两个List各有1000条数据）： 最简单的就是用双重循环进行比较，虽然简单，但是如果两个List的数据量都很大，那么运行时间将成数量级增长。循环次数为1000*1000 把一个List通过循环放入Map中，把需要比较的字段作为Map的Key，然后循环另外一个List，到Map里面去匹配。 Java代码123456789101112for(A a : aList)&#123; map.put(a.amount,a); &#125; for(B b : bList)&#123; A a = map.get(b.amount); if(a==null)&#123; //a==null则说明没有同b匹配的项 &#125;else&#123; //a!=null则说明匹配上了 &#125; &#125; 由于在Map中取数非常快，主要的耗时就在业务处理和循环上。循环次数为1000*2 但是第2种方法还是有不足的地方： 1、当比较的值有相同的时候，由于Key必须唯一，所以后面的值会覆盖掉前面的数据 2、当比较的内容比较复杂，或者是多项的时候，就比较难处理 我想在平时开发中大家应该都会遇到这样的问题吧，不知道大家有没有更好的方法来解决这个问题！！"},{"title":"使用sinopia搭建本地npm仓库","permalink":"/ckilas0is00570xqim80w89vq/","text":"参考：http://www.tuicool.com/articles/UziA7ra1、 全局安装sinopia,macOS/linux环境需要sudo权限; 1$ sudo npm install sinopia -g 2、 运行sinopia启动服务器，端口默认是4873 123$ sinopia warn --- config file - /opt/sinopia/config.yaml warn --- http address - http://localhost:4873/ 3、 在局域网的服务器上使用ip+4873的形式是访问不了的，因为启动的localhost，所以我们修改 /opt/sinopia/config.yaml ,在最后一行加上 1listen: 0.0.0.0:4873 4、 使用sinopia启动就可以使用ip+4873访问了123$ sinopia warn --- config file - /opt/sinopia/config.yaml warn --- http address - http://0.0.0.0:4873/ 该项目好像不维护了，后续可能会迁移到：verdaccio"},{"title":"解决ORA-28000","permalink":"/ckilas0jh006k0xqigbd632sw/","text":"转载自：http://jingyan.baidu.com/article/75ab0bcbe3e258d6874db255.html 在oracle中，连续十次尝试登陆不成功，那么此账户将会被锁定（lock）。当使用被锁定的账户登录时，系统会报错：ORA-28000: the account is locked。本文描述次错误的解决思路。方法/步骤 使用system或者sys账户登录，注意请以管理员身份登录。Sytem和sys的默认密码请在网上查找。本文以sys账户为例，sys的默认密码是：change_on_install 。 使用命令解锁用户。命令为：alter user username account unlock;其中username为被锁定的用户名。 重置用户密码。命令为：alter user username identified by password;其中username为用户名，password为新密码。 使用账户重新尝试登陆。如果命令全部执行成功，那么应该可以正常登陆系统。"},{"title":"您应升级到 MySQL 5.5.0 或更高版本","permalink":"/ckilas0jd00690xqizy6jjlh3/","text":"解决思路：1、升级mysql版本。2、降级phpmyadmin版本的检查。因为我的CentOS是我常用版本，所以不想改。那就降级phpmyadmin版本中的检查。 12345vim /var/www/html/phpmyadmin/libraries/common.inc.php# 50500if (PMA_MYSQL_INT_VERSION &lt; 50500) &#123; ## 修改为 50100if (PMA_MYSQL_INT_VERSION &lt; 50100) &#123; 这样就把phpmyadmin的需求5.1.0了"},{"title":"SecureCRT等连接linux虚拟机慢","permalink":"/ckilas0h3001c0xqi8948awxi/","text":"一般是等待十几秒才连上确认linux防火墙关闭的情况下方法是修改/etc/ssh/sshd_config文件，添加(或者修改)一行: UseDNS no 重启一下sshd服务器就可以解决了现在连接inux服务器一般都是使用SSH远程连接的方式。最近新装了一台服务器，发现telnet时速度很快，ping时一切也正常，但SSH连接的时候却很慢。经过网上资料查询，大致是有以下几种原因： 1、SERVER的SSHD会去DNS查找访问的CLIENT IP的HOSTNAME，如果DNS不可用或者没有相关记录，就会消耗一段时间。 2、在authentication gssapi-with-mic有时候也会消耗一段时间一、测试查找具体原因： 1、使用ssh -v host进行debug1# ssh -v 192.168.100.10 然后就会输出一大堆debug，通过debug信息就可以看到连接到什么地方被耽搁了比如会显示如下信息：123456[html] view plaincopyprint?debug1: Next authentication method: gssapi-with-micdebug1: Unspecified GSS failure. Minor code may provide more informationNo credentials cache founddebug1: Next authentication method: gssapi-with-micdebug1: Unspecified GSS failure. Minor code may provide more informationNo credentials cache found 2、检测连接时间1# time ssh root@192.168.100.10 exit 二、解决方法（建议一个个设置，因为每个人连接慢的原因都不一样）： 注意：修改之后记得重启sshd服务1# service sshd restart 1、关闭DNS反向解析在linux中，默认就是开启了SSH的反向DNS解析,这个会消耗大量时间，因此需要关闭。12# vi /etc/ssh/sshd_configUseDNS=no 在配置文件中，虽然UseDNS yes是被注释的，但默认开关就是yes2、关闭SERVER上的GSS认证在authentication gssapi-with-mic有很大的可能出现问题，因此关闭GSS认证可以提高ssh连接速度。12# vi /etc/ssh/sshd_configGSSAPIAuthentication no 3、修改server上nsswitch.conf文件1# vi /etc/nsswitch.conf 找到hosts： files dns改为hosts：fileshosts： files dns这一行含义是对于访问的主机进行域名解析的顺序，是先访问file，也就是/etc/hosts文件，如果hosts中没有记录域名，则访问dns，进行域名解析，如果dns也无法访问，就会等待访问超时后返回，因此等待时间比较长。注意：如果SERVER需要通过域名访问其他服务器，则需要保留此行。 4、修改SERVER上resolv.conf文件 4.1、删除/etc/resolv.conf中所有不使用的IP。 4.2、把nameserver全部删除，问题也能解决，但是服务器就无法上网了。 4.3、如果SERVER曾经配置过双网卡，则在该文件中会有一行目前不使用的IP地址，删除该行即可。 5、修改SERVER上hosts文件 在SERVER上/etc/hosts文件中把客户端的IP和HOSTNAME加入 6、打开SERVER上的IgnoreRhosts参数 IgnoreRhosts参数可以忽略以前登录过主机的记录，设置为yes后可以极大的提高连接速度12# vi /etc/ssh/sshd_configIgnoreRhosts yes ——————–以上的均在SERVER上设置，以下的均在CLIENT上设置———————– 7、修改客户端的hosts文件将目标SERVER的IP和域名加上去,使得本机的DNS服务能解析目标地址。12# vi /etc/hosts192.168.100.11 doiido.com 注：hosts文件格式为’目标SERVER_IP 目标SERVER_NAME’。但是使用这个方法有一个弊端，如果需要给每台SERVER都添加一个域名解析。8、修改客户端配置文件ssh_conf（注意，不是sshd_conf）1# vi /etc/ssh/ssh_conf 找到GSSAPIAuthentication yes改为GSSAPIAuthentication no"},{"title":"搭建subversion服务器(CentOS)","permalink":"/ckilas0jf006d0xqi6w6lviah/","text":"本文是基于centos6版本进行安装的。 安装1yum install subversion 配置本系统采用为每个项目单独建一版本库的策略。配置文件，密码文件，访问控制文件等都放在版本库的conf目录下。所以每次开始一个新项目都必须新建一个版本库，并重新配置各配置文件。还有很重要的一条，要求各组员重新配置客户端，包括服务器版本库路径，本地路径等信息。 建立版本库目录可建立多个，新建库后以下各项都需重新配置。注意区别安装目录与版本库目录,以下讲的都是版本库目录12mkdir –p /home/svn/repos#类似可以创建 mkdir –p /home/svn/repos2 /home/svn/repos3 建立svn版本库(与上面目录对应)1svnadmin create /home/svn/repos 执行此命令后svn自动在repos目录下添加必须的配置文件.注意: 版本库不同于一般的文件夹, 直接在操作系统上新建文件无法被SVN识别, 必须使用import等命令将文件导入版本库.此为svn内部指令，create用于新建版本库。请使用svn help查看详细说明。 修改版本库配置文件1vi /home/svn/repos/conf/svnserve.conf 各参数功能在配置文件的注释中有说明, 此处配置如下:[general]anon-access = none # 使非授权用户无法访问auth-access = write # 使授权用户有写权限password-db = passwd # 指明密码文件路径authz-db = authz # 访问控制文件realm = /home/svn/repos # 认证命名空间，subversion会在认证提示里显示，并且作为凭证缓存的关键字。其它采用默认配置. 各语句都必须顶格写, 左侧不能留空格, 否则会出错. 配置用户1vi /home/svn/repos/conf/passwd 输入以下内容：[users]username1 = password1username2 = password2可以添加多个，此为用户名密码对。 配置权限1vi /home/svn/repos/conf/authz 此配置文件设置各用户的授权。包括只读r，读写rw。没有列出的用户，则不允许访问。还可以对用户分组，具体请参考svn手册，以下是简单例子： #对仓库repos根目录权限设置[repos:/]user1 = rwuser2 = r 使用import导入文件新建好的版本库是空的，需要导入工作目录。// 这条语句将把路径/home/user/code下找到的文件导入到你创建的 Subversion 仓库中去1svn import /home/code/ file:///home/svn/repos/ -m “注释” 启动服务123svnserve -d -r /home/svn/svn checkout svn://ip/repos#输入用户名密码即可"},{"title":"Ubuntu版koala启动失败libudev.so.0 not found on Ubuntu 14.04","permalink":"/ckilas0hv00370xqi6l08o5fe/","text":"会显示某些库不存在，我们需要建立软链接，这个问题可能会在后续的版本尽心修复； 临时方案，在命令行执行：1sudo ln -s /lib/x86_64-linux-gnu/libudev.so.1 /lib/x86_64-linux-gnu/libudev.so.0"},{"title":"Ubuntu开机自动挂载ntfs分区","permalink":"/ckilas0h8001o0xqirykin6u2/","text":"在新的64位Ubuntu 12.04版本中 ntfs写入支持程序 不能正常运行。所以想Ubuntu自动挂载ntfs分区就要手动编辑/etc/fstab 文件。 /etc/fstab包含了挂在磁盘的必要信息，在系统启动时读入。 1、先用fdisk命令查看磁盘信息 123456/dev/sda1 * 1 851 6835626 83 Linux/dev/sda2 852 4039 25607610 f W95 Ext’d (LBA)/dev/sda5 945 2135 9566676 7 HPFS/NTFS/dev/sda6 2136 4039 15293848+ 7 HPFS/NTFS/dev/sda5 和 /dev/sda6 是要挂载的两个ntfs分区。 2、将以下内容添加到/etc/fstab 文件尾部，重启即可自动挂载NTFS分区了。 12/dev/sda6 /media/my ntfs-3g defaults,locale=zh_CN.UTF-8 0 0/dev/sda5 /media/tools ntfs-3g defaults,locale=zh_CN.UTF-8 0 0 3、最好的方式是安装ntfs-config软件去从页面上修改。 1sudo apt-get install ntfs-config"},{"title":"MySQL搭建AB复制备份","permalink":"/ckilas0gt000u0xqil6sn7zt8/","text":"1、安装两台Linux服务器； 2、使用ssh免密码登录(使用ssh-keygen -t rsa生成sshkey并将公钥导入authorized_keys文件中)； 3、关闭防火墙； 12345# Ubuntu/Debiansudo ufw disable# Redhat/CentOSsudo iptables stop &amp;&amp; chkconfig iptables off 4、master：my.cnf 123server_id = 1log-bin = binloglog-bin-index = binlog.index 5、slave：my.cnf1234server_id = 2log-bin =master.log# relay_log = /usr/share/mysql/mysql-relay-bin# relay_log_index = /usr/share/mysql/mysql-relay-bin.index 6、master查看binlog，需要在mysql的命令行执行；123flush tables with read lock;show master status; 得到binlog.000001,323unlock tables; 7、slave绑定binlog1change master to master_host=&apos;192.168.2.114&apos;,master_port=3306,master_user=&apos;root&apos;,master_password=&apos;admin&apos;,master_log_file=&apos;binlog.000001&apos;,master_log_pos=323; 8、查询slave的状态12start slave;show slave status; 9、在主库上操作，查看测试库 ERROR 1201 (HY000): Could not initialize master info structure; more error messages can be found in the MySQL error log 解决方案是：运行命令 stop slave; 成功执行后继续运行 reset slave;"},{"title":"CentOS单节点安装hadoop","permalink":"/ckilas0g300060xqi1o2ijx6m/","text":"最近要用到一个hadoop环境，由于资源有限，本文参照官方文档安装了hadoop单节点．参考地址：http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html为了方便，本文直接在root下面安装，生产环境不建议使用root账户． 运行环境： CentOS 6.9 i586 IP: 192.168.1.20 下面分为下面几个步骤完成 下载apache hadoop 安装系统必备的组件 配置linux免密码ssh登录 安装jdk1.8并做相关的配置 安装hadoop并配置 使用webhdfs查看文件系统 下载apache hadoop1234# 如果显示 -bash: wget: command not found 请执行 yum install wget 安装wget http://mirrors.hust.edu.cn/apache/hadoop/common/hadoop-2.8.1/hadoop-2.8.1.tar.gz# 我习惯把自己安装的软件放在opt下面，如果移动失败，可能没有权限，请切换到root执行：chmod 777 -R /opt/mv hadoop-2.8.1.tar.gz /opt/ 安装系统必备的组件123456789101112yum install ssh rsync# 下载完成后，请使用下面的命令测试ssh# 显示下面类似的结果，说明安装成功usage: ssh [-1246AaCfgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file] [-L [bind_address:]port:host:hostport] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-R [bind_address:]port:host:hostport] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] [user@]hostname [command] 配置linux免密码ssh登录使用下面的，生成ssh公私密钥123456789101112131415161718192021222324# 一路回车就好了，其实我也是新手 *_*ssh-keygen -t rsa# 执行效果是这样子的Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Created directory '/root/.ssh'.Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:d6:b9:15:d5:3f:0b:01:f6:f4:3f:04:9b:9d:bc:07:01 root@linux32The key's randomart image is:+--[ RSA 2048]----+| oE+o. || . ooB.o|| .+o*.|| . . o.o+|| S o . .o=|| . o .o|| . || || |+-----------------+ 查看~/.ssh下面已经生成了id_rsa和id_rsa.pub文件，前者是私钥匙，后者是公钥，现在开始授权自动登录1234#在.ssh目录下执行cat id_rsa.pub &gt;&gt; authorized_keys#给authorized_keys设置权限，这个很重要的chmod 600 authorized_keys 使用ssh连接自己测试，不需要输入密码就可以登录进去了，第一次可能会有一个提问，输入yes回车即可1ssh localhost 安装jdk1.8并做相关的配置12#将jdk解压到jdk1.8.0_144,然后添加环境变量echo \"export JAVA_HOME=/opt/jdk1.8.0_144\" &gt;&gt; /etc/profile 安装hadoop并配置设置环境变量123456#将hadoop解压到hadoop-2.8.1文件夹echo \"export HADOOP_HOME=/opt/hadoop-2.8.1\" &gt;&gt; /etc/profile#导出PATH变量echo \"export PATH=\\$PATH:\\$JAVA_HOME/bin:\\$HADOOP_HOME/bin:\\$HADOOP_HOME/sbin\" &gt;&gt; /etc/profile#刷新环境变量source /etc/profile 修改$HADOOP_HOME/etc/hadoop/hadoop-env.sh中的JAVA_HOME指向，修改为本机的JAVA_HOME，大约是25行左右1export JAVA_HOME=/opt/jdk1.8.0_144 配置单节点，修改$HADOOP_HOME/etc/hadoop/core-site.xml,追加下面的配置123456789101112&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://192.168.1.20:9000&lt;/value&gt; &lt;/property&gt; &lt;!--需要在/opt/hadoop-2.8.1手动创建hadoop_tmp--&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop-2.8.1/hadoop_tmp&lt;/value&gt; &lt;description&gt;A base for other temporary directories.&lt;/description&gt; &lt;/property&gt;&lt;/configuration&gt; 修改$HADOOP_HOME/etc/hadoop/hdfs-site.xml,追加下面的配置123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 使用下面的命令格式化文件系统并启动hdfs,启动之前必须在/etc/hosts中绑定主机名，否则会启动失败123456789#添加映射,我的主机名是linux32echo \"192.168.1.20 linux32\" &gt;&gt; /etc/hosts &amp;&amp; service network restarthdfs namenode -formatstart-dfs.sh#启动成功了，使用jps检查是否成功2609 SecondaryNameNode2453 DataNode2332 NameNode2717 Jps 使用webhdfs查看文件系统（如果访问不到，请查看防火墙是否允许50070端口） 其他问题1、You have loaded library /opt/hadoop-2.8.1/lib/native/libhadoop.so.1.0.0 which might have disabled stack guard. The VM will try to fix the stack guard now http://www.linuxidc.com/Linux/2014-04/100934p3.htm 123在hadoop-env.sh和yarn-env.sh中添加如下两行：export HADOOP_COMMON_LIB_NATIVE_DIR=$&#123;HADOOP_PREFIX&#125;/lib/nativeexport HADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_PREFIX/lib&quot; 2、namenode没有办法启动 最近遇到了一个问题，执行start-all.sh的时候发现JPS一下namenode没有启动 每次开机都得重新格式化一下namenode才可以 其实问题就出在tmp文件，默认的tmp文件每次重新开机会被清空，与此同时namenode的格式化信息就会丢失 于是我们得重新配置一个tmp文件目录 首先在home目录下建立一个hadoop_tmp目录 1sudo mkdir ~/hadoop_tmp 然后修改hadoop/conf目录里面的core-site.xml文件，加入以下节点：12345&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/home/chjzh/hadoop_tmp&lt;/value&gt; &lt;description&gt;A base for other temporary directories.&lt;/description&gt;&lt;/property&gt; 注意：我的用户是chjzh所以目录是/home/chjzh/hadoop_tmp OK了，重新格式化Namenode1hadoop namenode -format 然后启动hadoop1start-all.sh 执行下JPS命令就可以看到NameNode了"},{"title":"JS生成随机数","permalink":"/ckilas0gj000m0xqi9m4wjv4q/","text":"12345// 如果你希望生成任意值到任意值的随机数，公式就是这样的：// max - 期望的最大值// min - 期望的最小值parseInt(Math.random()*(max-min+1)+min,10);Math.floor(Math.random()*(max-min+1)+min);"},{"title":"AngularJS中$http服务在IE中缓存处理","permalink":"/ckilas0fq00000xqicvebq2kd/","text":"我们在项目中会很频繁的用到获取实时数据的形式展示界面，由于每次请求的url，参数都是一样的，在ie中就出现了缓存下来的问题。 下面我们通过配置$httpProvider修改默认的$http请求。 12345678app.config(['$httpProvider',function ($httpProvider) &#123; // 初始化$httpProvider的get请求配置 $httpProvider.defaults.headers.get = $httpProvider.defaults.headers.get || &#123;&#125;; // 修改请求默认值，不允许缓存 $httpProvider.defaults.headers.get['Cache-Control'] = 'no-cache'; $httpProvider.defaults.headers.get['Pragma'] = 'no-cache'; &#125;]); 再次在ie浏览器运行，相同的参数，每次获取的数据都是不一样的了，说明我们的配置生效了。 当然我们可以在所有的get请求后面拼接时间戳参数，来保证每次的请求都是不同的。"},{"title":"white-space处理断行","permalink":"/ckilas0ie004c0xqije66g4y8/","text":"white-space空白的处理方式，不止两个属性值，但在 IE6 中只支持这两个，所以不介绍其他的。 normal 多个连续英文空格压缩为一个英文空格显示，在空白处可换行。 nowrap 强制在同一行内显示所有文本，直到文本结束或者遭遇 br 对象。 word-wrap内容超过容器边界时是否断开转行。 normal 允许（只是允许，不是必须）内容顶开指定的容器边界。 break-word 内容将在边界内换行。 word-break换行的方式。 normal 英文在标点和空白处换行，中文在任何地方换行。 break-all 英文和中文都在任何地方换行，比如从一个英文单词的中间拆开换行。 keep-all 英文和中文都在标点和空白处换行。"},{"title":"CentOS最小安装setuptools安装","permalink":"/ckilas0g600080xqikfte4w2o/","text":"1、安装网络管理工具最小化安装的centos是没有图形化配置网络的应用的，也就是我们常说的setup； 那现在那安装setuptool吧，可以节省很多系统管理的时间。 # 安装setuptool 1yum install setuptool # 可以发现执行setup后不全，再安装一个用于系统服务管理 1yum install ntsysv # 再安装个防火墙，以及setup中配套的防火墙设置、网络设置 1yum install iptables # 安装setup中配套的防火墙设置 1yum install system-config-securitylevel-tui # 安装setup中配套的网络设置 1yum install system-config-network-tui 然后就可以运行的setup了。 2、安装中文语言包centos安装过程中，安装语言包时选择了english，在安装完毕后浏览中文网页或查看中文文档时总是宣誓乱码，因此需要安装中文语言包，如果不能 从安装盘进行安装，可以通过yum进行安装。 yum可以安装一个分组，包括该语言所有的功能和设置，使用下面的命令；1yum groupinstall &lt;language&gt;-support 在上面的命令中， 是下列之一: assamese, bengali, chinese, gujarati, hindi, japanese, kannada, korean, malayalam, marathi, oriya, punjabi, sinhala, tamil, thai, 或 telegu。 locale -a查看系统支持的语言LANG=zh_CN.gb2312设置当前为中文，只对当时有效 1vim /etc/sysconfig/i18n 将LANG=&quot;zh_CN.UTF-8&quot; 换成 LANG=&quot;en_US.UTF-8&quot;"},{"title":"CentOS设置默认启动命令行","permalink":"/ckilas0g8000a0xqisyn9hzp3/","text":"CentOS中如何进入图形界面和文字界面，Linux真正的服务器是不会运行图形化界面的，怎么样才能在不卸载桌面的前提下开机直接进入命令界面呢？（我安装的是CentOS 6.0）下面就简单介绍以下： 一、如果要进入图形界面：1.首先得安装有图形界面，一般为X-window图形界面。2.启动linux在终端下输入:startx 即可进入X11的图形操作界面。 二、在图形界面还可以在多个界面中进行切换：在X-window图形操作界面中按“Alt+Ctrl+功能键Fn n=1~6 ”就可以进入Console字符操作界面。按“Alt+Ctrl+F7”即可回到刚才的X-window中。 三、如何每次都自动进入xwindos或者字符界面？开机后进入图形化界面还是进入命令行取决于inittab文件中的配置。该文件位于etc目录下。打开/etc/inittab 文件 1vim /etc/inittab 在默认的 run level 设置中,可以看到第一行书写默认的 run level 等级为 5,即图形 界面将第一行的 5 修改为 3 即可。保存文件后重启系统你就可以看见是启动的文本界面了。 另外在文本模式如果想启动图形界面，可以使用下面的方法（首先你安装了图形界面）： 1startx 运行级别（run level）的说明如下 1234567# 0 – halt (Do NOT set initdefault to this)# 1 – Single user mode# 2 – Multiuser, without NFS (The same as 3, if you do not have networking)# 3 – Full multiuser mode# 4 – unused# 5 – X11# 6 – reboot (Do NOT set initdefault to this)"}]}